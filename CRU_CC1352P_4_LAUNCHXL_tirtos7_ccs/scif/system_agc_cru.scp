<?xml version="1.0" encoding="UTF-8"?>
<project name="System AGC  CRU CODE" version="2.9.0.208">
    <desc><![CDATA[Samples 4 channels for TX/RX voltage, calculates min and max values of these measures for each channel and raises AlertInterrupt for main application when done.
Sampling occurs only when TDD is locked and connected to the configured GPIO pins.]]></desc>
    <pattr name="Apply default power mode">0</pattr>
    <pattr name="Board">CC1352P* LaunchPad</pattr>
    <pattr name="Chip name">CC1352P1F3</pattr>
    <pattr name="Chip package">QFN48 7x7 RGZ</pattr>
    <pattr name="Chip revision">E</pattr>
    <pattr name="Clock in active mode">0</pattr>
    <pattr name="Code prefix"></pattr>
    <pattr name="Default power mode">0</pattr>
    <pattr name="Operating system">TI-RTOS</pattr>
    <pattr name="Output directory">C:/Users/cellium/workspace_v12/crs_tirtos_test/CRU_CC1352P_4_LAUNCHXL_tirtos7_ccs/scif</pattr>
    <pattr name="RTC tick interval (16.16 format)">2000</pattr>
    <pattr name="Run-time logging UART RX pin"></pattr>
    <pattr name="Run-time logging UART TX pin"></pattr>
    <task name="System AGC">
        <desc><![CDATA[Samples 4 channels for TX/RX voltage, calculates min and max values of these measures for each channel and raises AlertInterrupt for main application when done.
Sampling occurs only when TDD is locked and connected to the configured GPIO pins.]]></desc>
        <tattr name="ACC_VALUE_BUFFER_SIZE" type="expr" content="const" scope="task" min="0" max="65535">CHANNEL_COUNT * 8</tattr>
        <tattr name="ADC_SAMPLE_RATE" type="expr" content="const" scope="task" min="0" max="65535">100000</tattr>
        <tattr name="AVERAGE_SIZE" desc="The size of the array of the sums of the samples results (for each channel sum of samples from DLRF, ULRF, DLIF, ULIF)." type="expr" content="const" scope="task" min="0" max="65535">CHANNELS_NUMBER*4</tattr>
        <tattr name="BUFFER_SIZE" desc="Number of measures on each channel from one sample cycle (one DL/UL period)" type="expr" content="const" scope="task" min="0" max="65535">10</tattr>
        <tattr name="CHANNELS_NUMBER" desc="Number of channels" type="expr" content="const" scope="task" min="0" max="65535">4</tattr>
        <tattr name="CHANNEL_COUNT" type="expr" content="const" scope="task" min="0" max="65535">4</tattr>
        <tattr name="CHANNEL_HOLD_NUM" type="expr" content="const" scope="task" min="0" max="65535">4</tattr>
        <tattr name="MIN_MAX_CHANNELS_SIZE" desc="15% of results from all samples across cycles for a given channel" type="expr" content="const" scope="task" min="0" max="65535">(MODES_SIZE - (MODES_SIZE/4))/CHANNELS_NUMBER</tattr>
        <tattr name="MODES_CHANNEL_SIZE" desc="20% of results from all samples across cycles for a given channel" type="expr" content="const" scope="task" min="0" max="65535">MODES_SIZE / CHANNELS_NUMBER</tattr>
        <tattr name="MODES_SIZE" desc="20% of sample across all cycles and channels" type="expr" content="const" scope="task" min="0" max="65535">(MULTI_RESULT_SIZE / 10) * 2</tattr>
        <tattr name="MULTI_BUFFER_SIZE" desc="Number of samples from all channels in each sample cycle" type="expr" content="const" scope="task" min="0" max="65535">BUFFER_SIZE * CHANNELS_NUMBER</tattr>
        <tattr name="MULTI_RESULT_SIZE" desc="Total number of measures from all channels across all samples cycles" type="expr" content="const" scope="task" min="0" max="65535">SAMPLE_SIZE*MULTI_BUFFER_SIZE</tattr>
        <tattr name="RESULTS" desc="Number of measures for a channel across all sample cycles" type="expr" content="const" scope="task" min="0" max="65535">BUFFER_SIZE*SAMPLE_SIZE</tattr>
        <tattr name="SAMPLE_SIZE" desc="Number of sample cycles" type="expr" content="const" scope="task" min="0" max="65535">2</tattr>
        <tattr name="SAMPLE_SZ" type="expr" content="const" scope="task" min="0" max="65535">180</tattr>
        <tattr name="TP_CHANNEL_COUNT" type="expr" content="const" scope="task" min="0" max="65535">4</tattr>
        <tattr name="cfg.Dio26" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="cfg.Dio27" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="cfg.channelsSwitch" desc="Channel select - 0: measure all channels, 1 - 4: measure only this channel" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="cfg.tddMode" desc="TDD mode - 0: ManualDL, 1: ManualUL, 2: Auto" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="cfg.unitType" desc="Type of unit - 0 : CDU, 1: CRU" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="input.Period1" desc="TDD env variable " type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="input.canTouchTester" type="expr" content="struct" scope="task" min="0" max="65535">1</tattr>
        <tattr name="input.gapStartRx" type="expr" content="struct" scope="task" min="0" max="65535">50</tattr>
        <tattr name="input.gapStartTx" type="expr" content="struct" scope="task" min="0" max="65535">50</tattr>
        <tattr name="input.gapStopRx" type="expr" content="struct" scope="task" min="0" max="65535">50</tattr>
        <tattr name="input.gapStopTx" type="expr" content="struct" scope="task" min="0" max="65535">50</tattr>
        <tattr name="input.randomDelayDL" size="SAMPLE_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="input.randomDelayUL" size="SAMPLE_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="input.tddLock" desc="TDD lock status" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.IFDetDLMax" size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.IFDetDLMin" size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">65535</tattr>
        <tattr name="output.IFDetULMax" size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.IFDetULMin" size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">65535</tattr>
        <tattr name="output.RxDetMax" size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.RxDetMin" size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">65535</tattr>
        <tattr name="output.TxDetMax" size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.TxDetMin" size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">65535</tattr>
        <tattr name="output.adcValue" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.channelsIdx" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.cruLock" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.pAccValueBuffer" desc="32-bit accumulator value for each ADC channel (L[0], H[0], ..., L[n], H[n]), to be accessed as a uint32_t array in the System CPU application" size="ACC_VALUE_BUFFER_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.tester" size="ACC_VALUE_BUFFER_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.TxDetMax" size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.TxDetMin" size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">65535</tattr>
        <tattr name="state.alertEnabled" desc="Is ALERT interrupt generation enabled?" type="expr" content="struct" scope="task" min="0" max="65535">1</tattr>
        <tattr name="state.channelHold" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.channelsIdx" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.channelsSwitch" desc="Channel select - 0: measure all channels, 1 - 4: measure only this channel (copied from cfg in Event A)" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.exit" desc="Set to exit the ADC data streamer" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.invalid" desc="signal that results of current sample cycle should be discarded and not copied to the results arrays." type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.ledCounter" desc="Determines which LED will turn on in Auto mode" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.ledOn" desc="bool variable to decide weather we light led or ont" type="expr" content="struct" scope="task" min="0" max="1">1</tattr>
        <tattr name="state.loop" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.pAccValueBuffer" desc="32-bit accumulator value for each ADC channel (L[0], H[0], ..., L[n], H[n]), for storage while accumulating sample values" size="ACC_VALUE_BUFFER_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.samplesCount" desc="The sample cycles counter" type="expr" content="struct" scope="task" min="0" max="65535">SAMPLE_SIZE</tattr>
        <tattr name="state.tddMode" desc="TDD mode - 0: ManualDL, 1: ManualUL, 2: Auto (copied from cfg in Event A)" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.unitType" desc="Type of unit - 0 : CDU, 1: CRU  (copied from cfg in Event A)" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <resource_ref name="ADC" enabled="1"/>
        <resource_ref name="AON Domain Functionality" enabled="0"/>
        <resource_ref name="Accumulator-Based Math" enabled="1"/>
        <resource_ref name="Analog Open-Drain Pins" enabled="0"/>
        <resource_ref name="Analog Open-Source Pins" enabled="0"/>
        <resource_ref name="Analog Pins" enabled="1">
            <io_usage name="SENSOR_OUTPUT" label="Analog sensor output">
                <uattr name="Pin count">3</uattr>
                <uattr name="Pin/0000">DIO24</uattr>
                <uattr name="Pin/0001">DIO23</uattr>
                <uattr name="Pin/0002">DIO25</uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
            </io_usage>
        </resource_ref>
        <resource_ref name="COMPA" enabled="0"/>
        <resource_ref name="COMPA Event Trigger" enabled="0"/>
        <resource_ref name="COMPB" enabled="0"/>
        <resource_ref name="COMPB Event Trigger" enabled="0"/>
        <resource_ref name="Delay Insertion" enabled="1"/>
        <resource_ref name="Differential Output Pins" enabled="0"/>
        <resource_ref name="Digital Input Pins" enabled="1">
            <io_usage name="TDD_LOCK" label="TDD lock pin">
                <uattr name="Configuration on initialization">-1</uattr>
                <uattr name="Configuration on uninitialization">-1</uattr>
                <uattr name="Pin count">0</uattr>
                <uattr name="Pin/0000">DIO15</uattr>
                <uattr name="Pin/0001"></uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
                <uattr name="Pin/0008"></uattr>
                <uattr name="Pin/0009"></uattr>
                <uattr name="Pin/0010"></uattr>
                <uattr name="Pin/0011"></uattr>
                <uattr name="Pin/0012"></uattr>
                <uattr name="Pin/0013"></uattr>
                <uattr name="Pin/0014"></uattr>
                <uattr name="Pin/0015"></uattr>
                <uattr name="Pin/0016"></uattr>
                <uattr name="Pin/0017"></uattr>
                <uattr name="Pin/0018"></uattr>
                <uattr name="Pin/0019"></uattr>
                <uattr name="Pin/0020"></uattr>
                <uattr name="Pin/0021"></uattr>
                <uattr name="Pin/0022"></uattr>
                <uattr name="Pin/0023"></uattr>
                <uattr name="Pin/0024"></uattr>
                <uattr name="Pin/0025"></uattr>
                <uattr name="Pin/0026"></uattr>
                <uattr name="Pin/0027"></uattr>
                <uattr name="Pin/0028"></uattr>
                <uattr name="Pin/0029"></uattr>
                <uattr name="Pin/0030"></uattr>
                <uattr name="Pin/0031"></uattr>
            </io_usage>
            <io_usage name="TDD_SYNCH" label="TDD synchronization pin">
                <uattr name="Configuration on initialization">0</uattr>
                <uattr name="Configuration on uninitialization">-1</uattr>
                <uattr name="Pin count">0</uattr>
                <uattr name="Pin/0000">DIO14</uattr>
                <uattr name="Pin/0001"></uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
                <uattr name="Pin/0008"></uattr>
                <uattr name="Pin/0009"></uattr>
                <uattr name="Pin/0010"></uattr>
                <uattr name="Pin/0011"></uattr>
                <uattr name="Pin/0012"></uattr>
                <uattr name="Pin/0013"></uattr>
                <uattr name="Pin/0014"></uattr>
                <uattr name="Pin/0015"></uattr>
                <uattr name="Pin/0016"></uattr>
                <uattr name="Pin/0017"></uattr>
                <uattr name="Pin/0018"></uattr>
                <uattr name="Pin/0019"></uattr>
                <uattr name="Pin/0020"></uattr>
                <uattr name="Pin/0021"></uattr>
                <uattr name="Pin/0022"></uattr>
                <uattr name="Pin/0023"></uattr>
                <uattr name="Pin/0024"></uattr>
                <uattr name="Pin/0025"></uattr>
                <uattr name="Pin/0026"></uattr>
                <uattr name="Pin/0027"></uattr>
                <uattr name="Pin/0028"></uattr>
                <uattr name="Pin/0029"></uattr>
                <uattr name="Pin/0030"></uattr>
                <uattr name="Pin/0031"></uattr>
            </io_usage>
        </resource_ref>
        <resource_ref name="Digital Open-Drain Pins" enabled="0"/>
        <resource_ref name="Digital Open-Source Pins" enabled="0"/>
        <resource_ref name="Digital Output Pins" enabled="1">
            <io_usage name="CHANNEL_CONTROL" label="Channel control PINS">
                <uattr name="Configuration on uninitialization">-1</uattr>
                <uattr name="Output drive strength">0</uattr>
                <uattr name="Output value on initialization">0</uattr>
                <uattr name="Pin count">2</uattr>
                <uattr name="Pin/0000">DIO26</uattr>
                <uattr name="Pin/0001">DIO27</uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
                <uattr name="Pin/0008"></uattr>
                <uattr name="Pin/0009"></uattr>
                <uattr name="Pin/0010"></uattr>
                <uattr name="Pin/0011"></uattr>
                <uattr name="Pin/0012"></uattr>
                <uattr name="Pin/0013"></uattr>
                <uattr name="Pin/0014"></uattr>
                <uattr name="Pin/0015"></uattr>
                <uattr name="Pin/0016"></uattr>
                <uattr name="Pin/0017"></uattr>
                <uattr name="Pin/0018"></uattr>
                <uattr name="Pin/0019"></uattr>
                <uattr name="Pin/0020"></uattr>
                <uattr name="Pin/0021"></uattr>
                <uattr name="Pin/0022"></uattr>
                <uattr name="Pin/0023"></uattr>
                <uattr name="Pin/0024"></uattr>
                <uattr name="Pin/0025"></uattr>
                <uattr name="Pin/0026"></uattr>
                <uattr name="Pin/0027"></uattr>
                <uattr name="Pin/0028"></uattr>
                <uattr name="Pin/0029"></uattr>
                <uattr name="Pin/0030"></uattr>
                <uattr name="Pin/0031"></uattr>
            </io_usage>
            <io_usage name="RED_LED" label="Controls the red LED">
                <uattr name="Configuration on uninitialization">-1</uattr>
                <uattr name="Output drive strength">0</uattr>
                <uattr name="Output value on initialization">0</uattr>
                <uattr name="Pin count">0</uattr>
                <uattr name="Pin/0000">DIO6</uattr>
                <uattr name="Pin/0001"></uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
                <uattr name="Pin/0008"></uattr>
                <uattr name="Pin/0009"></uattr>
                <uattr name="Pin/0010"></uattr>
                <uattr name="Pin/0011"></uattr>
                <uattr name="Pin/0012"></uattr>
                <uattr name="Pin/0013"></uattr>
                <uattr name="Pin/0014"></uattr>
                <uattr name="Pin/0015"></uattr>
                <uattr name="Pin/0016"></uattr>
                <uattr name="Pin/0017"></uattr>
                <uattr name="Pin/0018"></uattr>
                <uattr name="Pin/0019"></uattr>
                <uattr name="Pin/0020"></uattr>
                <uattr name="Pin/0021"></uattr>
                <uattr name="Pin/0022"></uattr>
                <uattr name="Pin/0023"></uattr>
                <uattr name="Pin/0024"></uattr>
                <uattr name="Pin/0025"></uattr>
                <uattr name="Pin/0026"></uattr>
                <uattr name="Pin/0027"></uattr>
                <uattr name="Pin/0028"></uattr>
                <uattr name="Pin/0029"></uattr>
                <uattr name="Pin/0030"></uattr>
                <uattr name="Pin/0031"></uattr>
            </io_usage>
            <io_usage name="GREEN_LED" label="Controls the green LED">
                <uattr name="Configuration on uninitialization">-1</uattr>
                <uattr name="Output drive strength">0</uattr>
                <uattr name="Output value on initialization">0</uattr>
                <uattr name="Pin count">0</uattr>
                <uattr name="Pin/0000">DIO7</uattr>
                <uattr name="Pin/0001"></uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
                <uattr name="Pin/0008"></uattr>
                <uattr name="Pin/0009"></uattr>
                <uattr name="Pin/0010"></uattr>
                <uattr name="Pin/0011"></uattr>
                <uattr name="Pin/0012"></uattr>
                <uattr name="Pin/0013"></uattr>
                <uattr name="Pin/0014"></uattr>
                <uattr name="Pin/0015"></uattr>
                <uattr name="Pin/0016"></uattr>
                <uattr name="Pin/0017"></uattr>
                <uattr name="Pin/0018"></uattr>
                <uattr name="Pin/0019"></uattr>
                <uattr name="Pin/0020"></uattr>
                <uattr name="Pin/0021"></uattr>
                <uattr name="Pin/0022"></uattr>
                <uattr name="Pin/0023"></uattr>
                <uattr name="Pin/0024"></uattr>
                <uattr name="Pin/0025"></uattr>
                <uattr name="Pin/0026"></uattr>
                <uattr name="Pin/0027"></uattr>
                <uattr name="Pin/0028"></uattr>
                <uattr name="Pin/0029"></uattr>
                <uattr name="Pin/0030"></uattr>
                <uattr name="Pin/0031"></uattr>
            </io_usage>
        </resource_ref>
        <resource_ref name="Dynamic Power Control" enabled="0"/>
        <resource_ref name="GPIO Event Trigger" enabled="1"/>
        <resource_ref name="I2C Master" enabled="0">
            <rattr name="SCL frequency">0</rattr>
            <rattr name="SCL stretch timeout">1</rattr>
            <io_usage>
                <uattr name="Output drive strength">1</uattr>
                <uattr name="SCL pin/0000"></uattr>
                <uattr name="SDA pin/0000"></uattr>
            </io_usage>
        </resource_ref>
        <resource_ref name="ISRC" enabled="0"/>
        <resource_ref name="LCD Controller" enabled="0">
            <rattr name="Waveform state count">8</rattr>
            <io_usage>
                <uattr name="Output drive strength">0</uattr>
                <uattr name="Pin count">20</uattr>
                <uattr name="Pin/0000"></uattr>
                <uattr name="Pin/0001"></uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
                <uattr name="Pin/0008"></uattr>
                <uattr name="Pin/0009"></uattr>
                <uattr name="Pin/0010"></uattr>
                <uattr name="Pin/0011"></uattr>
                <uattr name="Pin/0012"></uattr>
                <uattr name="Pin/0013"></uattr>
                <uattr name="Pin/0014"></uattr>
                <uattr name="Pin/0015"></uattr>
                <uattr name="Pin/0016"></uattr>
                <uattr name="Pin/0017"></uattr>
                <uattr name="Pin/0018"></uattr>
                <uattr name="Pin/0019"></uattr>
                <uattr name="Pin/0020"></uattr>
                <uattr name="Pin/0021"></uattr>
                <uattr name="Pin/0022"></uattr>
                <uattr name="Pin/0023"></uattr>
                <uattr name="Pin/0024"></uattr>
                <uattr name="Pin/0025"></uattr>
                <uattr name="Pin/0026"></uattr>
                <uattr name="Pin/0027"></uattr>
                <uattr name="Pin/0028"></uattr>
                <uattr name="Pin/0029"></uattr>
                <uattr name="Pin/0030"></uattr>
                <uattr name="Pin/0031"></uattr>
            </io_usage>
        </resource_ref>
        <resource_ref name="Math and Logic" enabled="1"/>
        <resource_ref name="Multi-Buffered Output Data Exchange" enabled="0">
            <rattr name="Buffer count">2</rattr>
            <rattr name="Indicate overflow at buffer check">0</rattr>
            <rattr name="Indicate overflow at buffer switch">0</rattr>
            <rattr name="Prevent overflow at buffer switch">0</rattr>
        </resource_ref>
        <resource_ref name="Peripheral Sharing" enabled="0"/>
        <resource_ref name="Pulse Counter" enabled="0"/>
        <resource_ref name="RTC Multi-Event Capture" enabled="0"/>
        <resource_ref name="RTC-Based Execution Scheduling" enabled="0"/>
        <resource_ref name="Reference DAC" enabled="0"/>
        <resource_ref name="Run-Time Logging" enabled="1"/>
        <resource_ref name="SPI Chip Select" enabled="0"/>
        <resource_ref name="SPI Data Transfer" enabled="0">
            <rattr name="Bit rate">0</rattr>
            <rattr name="MISO configuration when inactive">-1</rattr>
            <rattr name="MOSI configuration on initialization">0</rattr>
            <rattr name="MOSI configuration on uninitialization">0</rattr>
            <rattr name="SCLK configuration on initialization">0</rattr>
            <rattr name="SCLK configuration on uninitialization">0</rattr>
            <io_usage>
                <uattr name="MISO pin/0000"></uattr>
                <uattr name="MOSI pin/0000"></uattr>
                <uattr name="SCLK pin/0000"></uattr>
            </io_usage>
        </resource_ref>
        <resource_ref name="Signal Observation" enabled="0"/>
        <resource_ref name="System CPU Alert" enabled="1"/>
        <resource_ref name="System Event Trigger" enabled="0"/>
        <resource_ref name="TDC" enabled="0"/>
        <resource_ref name="Timer 0" enabled="0"/>
        <resource_ref name="Timer 0 Event Trigger" enabled="1"/>
        <resource_ref name="Timer 1" enabled="1"/>
        <resource_ref name="Timer 1 Event Trigger" enabled="0"/>
        <resource_ref name="Timer 2" enabled="0"/>
        <resource_ref name="Timer 2 Event Trigger" enabled="0"/>
        <resource_ref name="UART Emulator" enabled="0">
            <rattr name="RX buffer size">64</rattr>
            <rattr name="Required idle period before enabling RX">11</rattr>
            <rattr name="TX buffer size">64</rattr>
            <io_usage>
                <uattr name="RX pin/0000"></uattr>
                <uattr name="TX pin/0000"></uattr>
            </io_usage>
        </resource_ref>
        <sccode name="event0" init_power_mode="0"><![CDATA[//cancel all scheduled event triggers
//evhCancelTrigger(0);
evhCancelTrigger(1);
//evhCancelTrigger(2);

if(cfg.channelsSwitch!=0){
    if(cfg.Dio26==1){
        gpioSetOutput(cfg.pAuxioOChannelControl[0]);//aux 23-->DIO 26
    }else{
        gpioClearOutput(cfg.pAuxioOChannelControl[0]);//aux 23-->DIO 26
    }

    if(cfg.Dio27==1){
        gpioSetOutput(cfg.pAuxioOChannelControl[1]);//aux 22-->DIO 27

    }else{
        gpioClearOutput(cfg.pAuxioOChannelControl[1]);//aux 23-->DIO 26
    }
}


U16 z=0;

z = state.channelHold;
utilIncrAndWrap(z, CHANNEL_HOLD_NUM; state.channelHold);

if(z==0){
    z = state.channelsIdx;
    utilIncrAndWrap(z, TP_CHANNEL_COUNT; state.channelsIdx);
}





//// update state's TDD mode, channels select and unit Type from the cfg (only on the start of a new sampling cycle)
//if(state.test == (SAMPLE_SZ-1)){
//    state.tddMode = cfg.tddMode;
//    state.channelsSwitch = cfg.channelsSwitch;
//    state.unitType = cfg.unitType;
//}

//// check if the TDD mode was changed in the middle of the sampling cycles
if(state.tddMode == cfg.tddMode){
    state.invalid = 0;
}
//else{
//    // if it was, mark currently stored result as invalid, advance the sample counter to the last cycle
//    // and trigger the next event so results will get discarded
//    state.invalid = 1;
//    state.samplesCount = 1;
//    evhSetupTimer0Trigger(1, 1, 2);
//    fwWaitForEvSignal(FW_WAIT_SIGNAL_TIMER0_EV, 1);
//}



// if tdd mode is auto
if(state.tddMode == 0){
    //**Led logic**//
    if(state.ledCounter == 0){
        gpioSetOutput(AUXIO_O_RED_LED);
        gpioSetOutput(AUXIO_O_GREEN_LED);
        //turn off cruLock
        output.cruLock=0;
    }
    if(state.ledCounter >= 100){
        gpioSetOutput(AUXIO_O_RED_LED);
        gpioSetOutput(AUXIO_O_GREEN_LED);
        //turn off cruLock
        output.cruLock=0;
        state.ledCounter = 0;
    }
    state.ledCounter += 1;
    if(state.ledOn==0){
        gpioClearOutput(AUXIO_O_RED_LED);
        gpioClearOutput(AUXIO_O_GREEN_LED);
    }
    //**Led logic**//

    //get the TDD lock
    U16 lock;
    // CRU gets lock status via a meassage from CDU, checks and updates periodically
    lock = input.tddLock;
    //if locked, activate the rising edge interrupt on event B
    if(lock == 1){
        evhSetupGpioTrigger(1, AUXIO_I_TDD_SYNCH, 1, EVH_GPIO_TRIG_ON_EDGE);
    }
    //Activate timer trigger on event A, so if interrupt does not occur or there is no lock then
    //event runs again from the start
    //timer of 100 ms
    evhSetupTimer0Trigger(0, 100, 2);

}else{
    // if mode is not auto, trigger event B immediately
    evhSetupTimer0Trigger(1, 1, 2);
}
//evhSetupGpioTrigger(1, AUXIO_I_TDD_SYNCH, 1, EVH_GPIO_TRIG_ON_MATCH);]]></sccode>
        <sccode name="event1" init_power_mode="0"><![CDATA[///rising edge - CDU: Tx det(Rf DL)/IF det (DL)
//              CRU: Rx det(Rf DL)/IF det (DL)
//cancel all scheduled event triggers
evhCancelTrigger(0);
//evhCancelTrigger(1);
//evhCancelTrigger(2);
//enter event code only if Manual DL mode or Auto(skip if Manual UL)
if(state.tddMode != 2){
    //**Led logic**//
    // turn DL LED on (in auto mode it stays on only half the time)
    if(state.tddMode == 0){
        if(state.ledCounter < 50){
            gpioClearOutput(AUXIO_O_RED_LED);
            gpioSetOutput(AUXIO_O_GREEN_LED);
            //set cruLock
            output.cruLock=1;
        }
    }else{ // state.tddMode != 0
        gpioClearOutput(AUXIO_O_RED_LED);
        gpioSetOutput(AUXIO_O_GREEN_LED);//sets BLUE static
    }
    if(state.ledOn==0){
        gpioClearOutput(AUXIO_O_RED_LED);
        gpioClearOutput(AUXIO_O_GREEN_LED);
    }
    //**Led logic**//


    fwDelayUs(input.gapStartTx);
    //channel switch config
    U16 z=0;
    z = state.channelsIdx;
    //    utilIncrAndWrap(z, TP_CHANNEL_COUNT; state.channelsIdx);
    if(cfg.channelsSwitch==0){
        if(state.channelsIdx==3){
            gpioSetOutput(cfg.pAuxioOChannelControl[0]);//aux 23-->DIO 26
            gpioSetOutput(cfg.pAuxioOChannelControl[1]);//aux 22-->DIO 27
        }
        if(state.channelsIdx==2){
            gpioClearOutput(cfg.pAuxioOChannelControl[0]);//aux 23-->DIO 26
            gpioSetOutput(cfg.pAuxioOChannelControl[1]);//aux 22-->DIO 27
        }
        if(state.channelsIdx==1){
            gpioSetOutput(cfg.pAuxioOChannelControl[0]);//aux 23-->DIO 26
            gpioClearOutput(cfg.pAuxioOChannelControl[1]);//aux 22-->DIO 27
        }
        if(state.channelsIdx==0){
            gpioClearOutput(cfg.pAuxioOChannelControl[0]);//aux 23-->DIO 26
            gpioClearOutput(cfg.pAuxioOChannelControl[1]);//aux 22-->DIO 27
        }
        output.channelsIdx=state.channelsIdx;
    }else{
        output.channelsIdx=cfg.channelsSwitch;
        state.channelsIdx=cfg.channelsSwitch;
    }





       adcDisable();
    adcSelectGpioInput(cfg.pAuxioASensorOutput[1]); //AUX Mapping 26--->DIO 23 TX det
    adcEnableSync(ADC_REF_FIXED, ADC_SAMPLE_TIME_5P3_US , ADC_TRIGGER_MANUAL); // MANUAl sampling, 2.7 us sample time, the fastest possible
    //     adcEnableSync(ADC_REF_FIXED, ADC_SAMPLE_TIME_2P7_US, ADC_TRIGGER_AUX_TIMER1); // period sampling, 2.7 us sample time, the fastest possible



    adcFlushFifo();

    // Initialize variables, only 6 are available
    U16 a = 0;
    S16 b = 0;
    U16 c = 0;
    U16 n = 0;

    U16 accValueBufferOutputOffset = #output.pAccValueBuffer - #state.pAccValueBuffer;
    U16* pAccValueBuffer = #state.pAccValueBuffer[0]; //To create a pointer to a data structure member, use the # operator.
    if(state.channelsIdx == 0){
        pAccValueBuffer = #state.pAccValueBuffer[0];
    }
    if(state.channelsIdx == 1){
        pAccValueBuffer=#state.pAccValueBuffer[2];
    }
    if(state.channelsIdx == 2){
        pAccValueBuffer= #state.pAccValueBuffer[4];
    }
    if(state.channelsIdx == 3){
        pAccValueBuffer= #state.pAccValueBuffer[6];
    }


    n = 0;
    U16 accSampleCount = 0;
    while (n < SAMPLE_SZ) {
        U16 accExt;
        U16 accValueL;
        U16 accValueH;

        // Reset the accumulator for the first sample in a block, or restore the accumulator for the current channel
        if (accSampleCount == 0) {
             accReset();
        } else {
            U16 accValueL = *(pAccValueBuffer++);
            U16 accValueH = *(pAccValueBuffer++);
            accSet32u(accValueH, accValueL);
            pAccValueBuffer -= 2;
        }
        U16 adcValue;
        // this triggers the driver to start a measure and place the result in the output array
        adcGenManualTrigger();
        adcReadFifo(adcValue);
        U16 a=n;
        n=state.channelsIdx;
        //min, max, sum calculations
        if(adcValue<=state.TxDetMin[n]){
            state.TxDetMin[n]=adcValue;
        }
        if(adcValue>=state.TxDetMax[n]){
            state.TxDetMax[n]=adcValue;
        }

        n=a;

        // Add the ADC value to the accumulator
        accAdd16u(adcValue);
        accGetAll(accExt, accValueH, accValueL);


        // Before the accumulator contains the wanted number of samples: Save the accumulator value to
        // state.pAccValueBuffer[], so it can be restored in the next iteration
        if (accSampleCount != (SAMPLE_SZ - 1)) {
            *(pAccValueBuffer++) = accValueL;
            *(pAccValueBuffer++) = accValueH;
            pAccValueBuffer -= 2;

        // When the accumulator contains the wanted number of samples: Save the accumulator value to
        // output.pAccValueBuffer[] instead, so it can be handed over to the System CPU application
        } else{
            if (state.invalid != 1) {
                if(input.canTouchTester==1){

                }
            }
            *(pAccValueBuffer++) = accValueL;
            *(pAccValueBuffer++) = accValueH;
            pAccValueBuffer -= 2;

        }

        n += 1;
        accSampleCount+=1;

    }//end of   while (n < MULTI_BUFFER_SIZE) {

    if(state.invalid != 1){
        if(state.alertEnabled == 1) {
            if(input.canTouchTester==1){
            state.alertEnabled = 0;
            input.canTouchTester=0;
             U16 accValueL = *(pAccValueBuffer++);
            U16 accValueH = *(pAccValueBuffer++);
             pAccValueBuffer -= 2;
                 pAccValueBuffer += accValueBufferOutputOffset; //move to output struct
                *(pAccValueBuffer++) = accValueL;
                *(pAccValueBuffer++) = accValueH;
                pAccValueBuffer -= 2;
                pAccValueBuffer -= accValueBufferOutputOffset; //move back to state struct
            n=state.channelsIdx;
         //min, max, sum calculations
//        if(state.TxDetMin[n]<=output.TxDetMin[n]){
           output.TxDetMin[n]=state.TxDetMin[n];
//        }
//        if(state.TxDetMax[n]>=output.TxDetMax[n]){
            output.TxDetMax[n] =state.TxDetMax[n];
//        }

            fwGenQuickAlertInterrupt();

           state.TxDetMin[n]=65535;
           state.TxDetMax[n]=0;

        }
    }
    }


    // reset all variables and decalre the rest of necessary variables
    n = 0;
































    //    // Calculate the memory offset between the accumulator value buffer in the output and state data structures.
    //    // We'll use this to quickly move the pointer back and forth (saves 3 instructions per move).
    //    //pAccValueBuffer[0]-pAccValueBuffer[1]: Tx channel 0
    //    //pAccValueBuffer[2]-pAccValueBuffer[3]: Tx channel 1
    //    //pAccValueBuffer[4]-pAccValueBuffer[5]: Tx channel 2
    //    //pAccValueBuffer[6]-pAccValueBuffer[7]: Tx channel 3
    //
    //    //pAccValueBuffer[8]-pAccValueBuffer[9]:   Rx channel 0
    //    //pAccValueBuffer[10]-pAccValueBuffer[11]: Rx channel 1
    //    //pAccValueBuffer[12]-pAccValueBuffer[13]: Rx channel 2
    //    //pAccValueBuffer[14]-pAccValueBuffer[15]: Rx channel 3
    //
    //    //pAccValueBuffer[16]-pAccValueBuffer[17]: IF Det DL channel 0
    //    //pAccValueBuffer[18]-pAccValueBuffer[19]: IF Det DL channel 1
    //    //pAccValueBuffer[20]-pAccValueBuffer[21]: IF Det DL channel 2
    //    //pAccValueBuffer[22]-pAccValueBuffer[23]: IF Det DL channel 3
    //
    //    //pAccValueBuffer[24]-pAccValueBuffer[25]: IF Det UL channel 0
    //    //pAccValueBuffer[26]-pAccValueBuffer[27]: IF Det UL channel 1
    //    //pAccValueBuffer[28]-pAccValueBuffer[29]: IF Det UL channel 2
    //    //pAccValueBuffer[30]-pAccValueBuffer[31]: IF Det UL channel 3
    //    //To create a pointer to a data structure member, use the # operator.
    //    U16 accValueBufferOutputOffset = #output.pAccValueBuffer - #state.pAccValueBuffer;
    //    U16* pAccValueBuffer = #state.pAccValueBuffer[0]; //To create a pointer to a data structure member, use the # operator.
    //    if(state.channelsIdx == 0){
    //        pAccValueBuffer = #state.pAccValueBuffer[8];
    //    }
    //    if(state.channelsIdx == 1){
    //        pAccValueBuffer = #state.pAccValueBuffer[10];
    //    }
    //    if(state.channelsIdx == 2){
    //        pAccValueBuffer = #state.pAccValueBuffer[12];
    //    }
    //    if(state.channelsIdx == 3){
    //        pAccValueBuffer = #state.pAccValueBuffer[14];
    //    }
    //    U16 f = 0;
    //
    //
    //
    //    // while(f<SAMPLE_SZ)  {
    //    U16 n = 0;
    //    U16 accExt=0;
    //    U16 accValueL=0;
    //    U16 accValueH=0;
    //    // Reset the accumulator for the first sample in a block, or restore the accumulator for the current channel
    //    U16 flagAccReset=0;
    //    if(state.channelsIdx==0){
    //        if (state.headSamplesCountRxDet[0] == 0) {
    //            accReset();
    //            flagAccReset=1;
    //        }
    //    }
    //
    //    if(state.channelsIdx==1){
    //        if (state.headSamplesCountRxDet[1] == 0) {
    //            accReset();
    //            flagAccReset=1;
    //        }
    //    }
    //    if(state.channelsIdx==2){
    //        if (state.headSamplesCountRxDet[2] == 0) {
    //            accReset();
    //            flagAccReset=1;
    //        }
    //    }
    //    if(state.channelsIdx==3){
    //        if (state.headSamplesCountRxDet[3] == 0) {
    //            accReset();
    //            flagAccReset=1;
    //        }
    //    }
    //
    //    if(flagAccReset==0) {
    //        U16 accValueL = *(pAccValueBuffer++);
    //        U16 accValueH = *(pAccValueBuffer++);
    //        accSet32u(accValueH, accValueL);
    //        pAccValueBuffer -= 2;
    //    }
    //    flagAccReset=0;
    //    //fwDelayUs(#delay, #range)
    //    //Delays execution of the next line by the specified number of microseconds.
    //    //To avoid busy waiting, the delay is implemented using AUX Timer 0.
    //    //Parameter value(s)
    //    //#delay : Delay value in microseconds
    //    //#range : Delay range (FW_DELAY_RANGE_N_US or FW_DELAY_RANGE_N_MS), for example FW_DELAY_RANGE_5_MS allows for a delay between 1 and 5000 microseconds
    //
    //    // select the correct pin according to unit type. For CDU we select
    //    // Rx detect PIN(Tal's card), for CRU we select Tx detect PIN(FEM card)
    //    adcSelectGpioInput(cfg.pAuxioASensorOutput[0]); //AUX Mapping 25--->DIO 24 RX det
    //
    //
    //
    //    //adcEnableSync(#refSource, #sampleTime, #trigger)
    //    //Enables the ADC for synchronous operation, with a fixed sampling period before each conversion.
    //    //The ADC is idle between conversions, and the ADC trigger starts the sampling period before the conversion.
    //    //This procedure must only be called when the ADC is disabled. To change ADC configuration, call adcDisable() before re-enabling the ADC.
    //    //Parameter value(s)
    //    //#refSource : ADC reference source, either ADC_REF_FIXED or ADC_REF_VDDS_REL
    //    //#sampleTime : ADC sampling time before each conversion, ADC_SAMPLE_TIME_N_US or ADC_SAMPLE_TIME_N_MS
    //    //#trigger : ADC trigger (ADC_TRIGGER_XYZ)
    //    //adcEnableSync(ADC_REF_FIXED, ADC_SAMPLE_TIME_2P7_US, ADC_TRIGGER_MANUAL); // manual sampling, 2.7 us sample time, the fastest possible
    //    adcEnableSync(ADC_REF_FIXED, ADC_SAMPLE_TIME_2P7_US, ADC_TRIGGER_AUX_TIMER1); // period sampling, 2.7 us sample time, the fastest possible
    //    adcFlushFifo();
    //    // Start ADC timer trigger at the configured period (rounded up)
    //    timer1Start(TIMER1_MODE_PERIODICAL, (24000000 + (ADC_SAMPLE_RATE - 1)) / ADC_SAMPLE_RATE, 0);
    //    // Wait for the ADC trigger (start of conversion)
    //    timer1Wait();
    //
    //
    //    if(state.channelsIdx==0){
    //        n = state.headSamplesCountRxDet[0];
    //    }
    //    if(state.channelsIdx==1){
    //        n = state.headSamplesCountRxDet[1];
    //    }
    //    if(state.channelsIdx==2){
    //        n = state.headSamplesCountRxDet[2];
    //    }
    //    if(state.channelsIdx==3){
    //        n = state.headSamplesCountRxDet[3];
    //    }
    //    adcReadFifo(output.RxDetSamples[n]); //ADC FIFO can store between between 0 and 4 samples.
    //    output.adcValue=output.RxDetSamples[n];
    //
    //
    //    // Add the ADC value to the accumulator
    //    accAdd16u(output.adcValue);
    //    accGetAll(accExt, accValueH, accValueL);
    //    // Before the accumulator contains the wanted number of samples: Save the accumulator value to
    //    // state.pAccValueBuffer[], so it can be restored in the next iteration
    //    U16 flagLastCycle=0;
    //    if(state.channelsIdx==0){
    //        if (state.headSamplesCountRxDet[0] != (SAMPLE_SZ - 1)) {
    //            flagLastCycle=1;
    //        }
    //    }
    //    if(state.channelsIdx==1){
    //        if (state.headSamplesCountRxDet[1] != (SAMPLE_SZ - 1)) {
    //            flagLastCycle=1;
    //        }
    //    }
    //
    //    if(state.channelsIdx==2){
    //        if (state.headSamplesCountRxDet[2] != (SAMPLE_SZ - 1)) {
    //            flagLastCycle=1;
    //        }
    //    }
    //
    //    if(state.channelsIdx==3){
    //        if (state.headSamplesCountRxDet[3] != (SAMPLE_SZ - 1)) {
    //            flagLastCycle=1;
    //        }
    //    }
    //
    //    if(flagLastCycle==1){
    //        *(pAccValueBuffer++) = accValueL;
    //        *(pAccValueBuffer++) = accValueH;
    //    }
    //    // When the accumulator contains the wanted number of samples: Save the accumulator value to
    //    // output.pAccValueBuffer[] instead, so it can be handed over to the System CPU application
    //    if(flagLastCycle==0) {
    //        pAccValueBuffer += accValueBufferOutputOffset;//moves the ptr to output structure
    //        *(pAccValueBuffer++) = accValueL;
    //        *(pAccValueBuffer++) = accValueH;
    //        pAccValueBuffer -= accValueBufferOutputOffset; //move the ptr back to state structure
    //    }
    //    // Update the head index
    //    state.test=n;
    //    utilIncrAndWrap(n, SAMPLE_SZ; state.test);
    //    if(state.channelsIdx==0){
    //        state.headSamplesCountRxDet[0]=state.test;
    //    }
    //    if(state.channelsIdx==1){
    //        state.headSamplesCountRxDet[1]=state.test;
    //    }
    //    if(state.channelsIdx==2){
    //        state.headSamplesCountRxDet[2]=state.test;
    //    }
    //    if(state.channelsIdx==3){
    //        state.headSamplesCountRxDet[3]=state.test;
    //    }
    //
    //
    //    n=state.channelsIdx;
    //    //min, max, sum calculations
    //    if(output.adcValue<output.RxDetMin[n]){
    //        output.RxDetMin[n]=output.adcValue;
    //    }
    //    if(output.adcValue>output.RxDetMax[n]){
    //        output.RxDetMax[n]=output.adcValue;
    //    }
    //
    //
    //
    //
    //
    //    //     If ALERT interrupt generation is enabled
    //    if (state.alertEnabled == 1) {
    //        if(state.headSamplesCountRxDet[n] == (SAMPLE_SZ)){
    //            rtlLogStructs(BV_RTL_LOG_OUTPUT);
    //            fwGenQuickAlertInterrupt();
    //            output.RxDetMax[n]=0;
    //            output.RxDetMin[n]=65535;
    //
    //
    //
    //            // Disable further generation to avoid unnecessary interrupts. It will be reenabled
    //            // by the application after handling the ALERT interrupt.
    //            state.alertEnabled = 0;
    //
    //        }
    //    }
    //
    //    adcDisable();
    //
    //    //move to sample IF det DL
    //    //pAccValueBuffer[0]-pAccValueBuffer[1]: Tx channel 0
    //    //pAccValueBuffer[2]-pAccValueBuffer[3]: Tx channel 1
    //    //pAccValueBuffer[4]-pAccValueBuffer[5]: Tx channel 2
    //    //pAccValueBuffer[6]-pAccValueBuffer[7]: Tx channel 3
    //
    //    //pAccValueBuffer[8]-pAccValueBuffer[9]:   Rx channel 0
    //    //pAccValueBuffer[10]-pAccValueBuffer[11]: Rx channel 1
    //    //pAccValueBuffer[12]-pAccValueBuffer[13]: Rx channel 2
    //    //pAccValueBuffer[14]-pAccValueBuffer[15]: Rx channel 3
    //
    //    //pAccValueBuffer[16]-pAccValueBuffer[17]: IF Det DL channel 0
    //    //pAccValueBuffer[18]-pAccValueBuffer[19]: IF Det DL channel 1
    //    //pAccValueBuffer[20]-pAccValueBuffer[21]: IF Det DL channel 2
    //    //pAccValueBuffer[22]-pAccValueBuffer[23]: IF Det DL channel 3
    //
    //    //pAccValueBuffer[24]-pAccValueBuffer[25]: IF Det UL channel 0
    //    //pAccValueBuffer[26]-pAccValueBuffer[27]: IF Det UL channel 1
    //    //pAccValueBuffer[28]-pAccValueBuffer[29]: IF Det UL channel 2
    //    //pAccValueBuffer[30]-pAccValueBuffer[31]: IF Det UL channel 3
    //    if(state.channelsIdx == 0){
    //        pAccValueBuffer = #state.pAccValueBuffer[16];
    //    }
    //    if(state.channelsIdx == 1){
    //        pAccValueBuffer = #state.pAccValueBuffer[18];
    //    }
    //    if(state.channelsIdx == 2){
    //        pAccValueBuffer = #state.pAccValueBuffer[20];
    //    }
    //    if(state.channelsIdx == 3){
    //        pAccValueBuffer = #state.pAccValueBuffer[22];
    //    }
    //    // Reset the accumulator for the first sample in a block, or restore the accumulator for the current channel
    //    flagAccReset=0;
    //    if(state.channelsIdx==0){
    //        if (state.headSamplesCountIFDLDet[0] == 0) {
    //            accReset();
    //            flagAccReset=1;
    //        }
    //    }
    //
    //    if(state.channelsIdx==1){
    //        if (state.headSamplesCountIFDLDet[1] == 0) {
    //            accReset();
    //            flagAccReset=1;
    //        }
    //    }
    //    if(state.channelsIdx==2){
    //        if (state.headSamplesCountIFDLDet[2] == 0) {
    //            accReset();
    //            flagAccReset=1;
    //        }
    //    }
    //    if(state.channelsIdx==3){
    //        if (state.headSamplesCountIFDLDet[3] == 0) {
    //            accReset();
    //            flagAccReset=1;
    //        }
    //    }
    //    U16 accExt_2=0;
    //    U16  accValueL_2 =0;
    //    U16  accValueH_2 =0;
    //    if(flagAccReset==0) {
    //        accValueL_2 = *(pAccValueBuffer++);
    //        accValueH_2 = *(pAccValueBuffer++);
    //        accSet32u(accValueH_2 ,accValueL_2);
    //        pAccValueBuffer -= 2;
    //    }
    //    flagAccReset=0;
    //
    //
    //    // select the IF pin
    //    adcSelectGpioInput(cfg.pAuxioASensorOutput[2]); //AUX Mapping 24--->DIO 25 IF det
    //    adcEnableSync(ADC_REF_FIXED, ADC_SAMPLE_TIME_2P7_US, ADC_TRIGGER_AUX_TIMER1); // period sampling, 2.7 us sample time, the fastest possible
    //    adcFlushFifo();
    //    // Wait for the ADC trigger (start of conversion)
    //    timer1Wait();
    //    fwDelayUs(150);
    //    if(state.channelsIdx==0){
    //        n = state.headSamplesCountIFDLDet[0];
    //    }
    //    if(state.channelsIdx==1){
    //        n = state.headSamplesCountIFDLDet[1];
    //    }
    //    if(state.channelsIdx==2){
    //        n = state.headSamplesCountIFDLDet[2];
    //    }
    //    if(state.channelsIdx==3){
    //        n = state.headSamplesCountIFDLDet[3];
    //    }
    //    adcReadFifo(output.IFDetDLSamples[n]); //ADC FIFO can store between between 0 and 4 samples.
    //    output.adcValue=output.IFDetDLSamples[n];
    //    // Add the ADC value to the accumulator
    //    accAdd16u(output.adcValue);
    //    accGetAll(accExt_2, accValueH_2, accValueL_2);
    //    // Before the accumulator contains the wanted number of samples: Save the accumulator value to
    //    // state.pAccValueBuffer[], so it can be restored in the next iteration
    //    flagLastCycle=0;
    //    if(state.channelsIdx==0){
    //        if (state.headSamplesCountIFDLDet[0] != (SAMPLE_SZ - 1)) {
    //            flagLastCycle=1;
    //        }
    //    }
    //    if(state.channelsIdx==1){
    //        if (state.headSamplesCountIFDLDet[1] != (SAMPLE_SZ - 1)) {
    //            flagLastCycle=1;
    //        }
    //    }
    //
    //    if(state.channelsIdx==2){
    //        if (state.headSamplesCountIFDLDet[2] != (SAMPLE_SZ - 1)) {
    //            flagLastCycle=1;
    //        }
    //    }
    //
    //    if(state.channelsIdx==3){
    //        if (state.headSamplesCountIFDLDet[3] != (SAMPLE_SZ - 1)) {
    //            flagLastCycle=1;
    //        }
    //    }
    //
    //    if(flagLastCycle==1){
    //        *(pAccValueBuffer++) = accValueL_2;
    //        *(pAccValueBuffer++) = accValueH_2;
    //    }
    //    // When the accumulator contains the wanted number of samples: Save the accumulator value to
    //    // output.pAccValueBuffer[] instead, so it can be handed over to the System CPU application
    //    if(flagLastCycle==0) {
    //        pAccValueBuffer += accValueBufferOutputOffset;//moves the ptr to output structure
    //        *(pAccValueBuffer++) = accValueL_2;
    //        *(pAccValueBuffer++) = accValueH_2;
    //        pAccValueBuffer -= accValueBufferOutputOffset; //move the ptr back to state structure
    //    }
    //
    //    // Update the head index
    //    state.test=n;
    //    utilIncrAndWrap(n, SAMPLE_SZ; state.test);
    //    if(state.channelsIdx==0){
    //        state.headSamplesCountIFDLDet[0]=state.test;
    //    }
    //    if(state.channelsIdx==1){
    //        state.headSamplesCountIFDLDet[1]=state.test;
    //    }
    //    if(state.channelsIdx==2){
    //        state.headSamplesCountIFDLDet[2]=state.test;
    //    }
    //    if(state.channelsIdx==3){
    //        state.headSamplesCountIFDLDet[3]=state.test;
    //    }
    //
    //    n=state.channelsIdx;
    //    //min, max, sum calculations
    //    if(output.adcValue<output.IFDetDLMin[n]){
    //        output.IFDetDLMin[n]=output.adcValue;
    //    }
    //    if(output.adcValue>output.IFDetDLMax[n]){
    //        output.IFDetDLMax[n]=output.adcValue;
    //    }
    //
    //
    //
    //
    //    // If ALERT interrupt generation is enabled
    //    if (state.alertEnabled == 1) {
    //        if(state.headSamplesCountIFDLDet[n]==(SAMPLE_SZ)){
    //            rtlLogStructs(BV_RTL_LOG_OUTPUT);
    //            fwGenQuickAlertInterrupt();
    //
    //
    //            output.IFDetDLMax[n]=0;
    //            output.IFDetDLMin[n]=65535;
    //            // Disable further generation to avoid unnecessary interrupts. It will be reenabled
    //            // by the application after handling the ALERT interrupt.
    //            state.alertEnabled = 0;
    //
    //        }
    //    }
    //    // Stop the ADC trigger and flush the ADC FIFO
    //    timer1Stop();
    //    fwDelayUs(3);// wait for any ongoing conversion (taking ~2.3 us) to finish
    //    adcFlushFifo();
    //    adcDisable();    //Disable the ADC driver after use
    //    evhSetupGpioTrigger(2, AUXIO_I_TDD_SYNCH, 0, EVH_GPIO_TRIG_ON_EDGE); //trigeer event c on falling edge of TDD Sync pin(Tx/Rx control)
    // if TDD mode is auto, trigger the next falling edge interrupt for UL Event C
    if(state.tddMode == 0){
        evhSetupGpioTrigger(2, AUXIO_I_TDD_SYNCH, 0, EVH_GPIO_TRIG_ON_EDGE); //trigeer event c on falling edge of TDD Sync pin(Tx/Rx control)
        evhSetupTimer0Trigger(0, 100, 2);
    }else{
        // if not, immediately trigger event A
        evhSetupTimer0Trigger(0, 1, 2);
    }
    //    f+=1;
    //        }//end of while f<SAMPLE_SZ

}else{
    // if mode is not Manual DL/ Auto, immediately trigger event C
    evhSetupTimer0Trigger(2, 1, 2);
}]]></sccode>
        <sccode name="event2" init_power_mode="0"><![CDATA[//faling edge - CDU: Rx det(Rf UL)/IF det (UL)
//              CRU: Tx det(Rf UL)/IF det (UL)
//cancel all scheduled event triggers
evhCancelTrigger(0);
//evhCancelTrigger(1);
//evhCancelTrigger(2);
//enter event code only if Manual UL mode or Auto(skip if Manual DL)
if(state.tddMode != 1){
    //**Led logic**//
    // turn UL LED on (in auto mode it stays on only half the time)
    if(state.tddMode == 0){
        if(state.ledCounter > 50){
            gpioClearOutput(AUXIO_O_GREEN_LED);
            gpioSetOutput(AUXIO_O_RED_LED);
            //set cruLock
            output.cruLock=1;
        }
    }else{
        gpioClearOutput(AUXIO_O_GREEN_LED);
        gpioSetOutput(AUXIO_O_RED_LED);
    }
    if(state.ledOn==0){
        gpioClearOutput(AUXIO_O_RED_LED);
        gpioClearOutput(AUXIO_O_GREEN_LED);
    }
    //**Led logic**//

//    adcDisable();
//    adcSelectGpioInput(cfg.pAuxioASensorOutput[1]); //AUX Mapping 26--->DIO 23 TX det
//    adcEnableSync(ADC_REF_FIXED, ADC_SAMPLE_TIME_2P7_US, ADC_TRIGGER_MANUAL); // MANUAl sampling, 2.7 us sample time, the fastest possible
//    //     adcEnableSync(ADC_REF_FIXED, ADC_SAMPLE_TIME_2P7_US, ADC_TRIGGER_AUX_TIMER1); // period sampling, 2.7 us sample time, the fastest possible
//
//
//
//    adcFlushFifo();
//
//    // Initialize variables, only 6 are available
//    U16 a = 0;
//    S16 b = 0;
//    U16 c = 0;
//    U16 n = 0;
//
//    U16 accValueBufferOutputOffset = #output.pAccValueBuffer - #state.pAccValueBuffer;
//    U16* pAccValueBuffer = #state.pAccValueBuffer[0]; //To create a pointer to a data structure member, use the # operator.
//    if(state.channelsIdx == 0){
//        pAccValueBuffer = #state.pAccValueBuffer[0];
//    }
//    if(state.channelsIdx == 1){
//        pAccValueBuffer=#state.pAccValueBuffer[2];
//    }
//    if(state.channelsIdx == 2){
//        pAccValueBuffer= #state.pAccValueBuffer[4];
//    }
//    if(state.channelsIdx == 3){
//        pAccValueBuffer= #state.pAccValueBuffer[6];
//    }
//
//
//    n = 0;
//    U16 accSampleCount = 0;
//    while (n < SAMPLE_SZ) {
//        U16 accExt;
//        U16 accValueL;
//        U16 accValueH;
//
//        // Reset the accumulator for the first sample in a block, or restore the accumulator for the current channel
//        if (accSampleCount == 0) {
//             accReset();
//        } else {
//            U16 accValueL = *(pAccValueBuffer++);
//            U16 accValueH = *(pAccValueBuffer++);
//            accSet32u(accValueH, accValueL);
//            pAccValueBuffer -= 2;
//        }
//        U16 adcValue;
//        // this triggers the driver to start a measure and place the result in the output array
//        adcGenManualTrigger();
//        adcReadFifo(adcValue);
//        U16 a=n;
//        n=state.channelsIdx;
//        //min, max, sum calculations
//        if(adcValue<state.TxDetMin[n]){
//            state.TxDetMin[n]=adcValue;
//        }
//        if(adcValue>state.TxDetMax[n]){
//            state.TxDetMax[n]=adcValue;
//        }
//
//        n=a;
//
//        // Add the ADC value to the accumulator
//        accAdd16u(adcValue);
//        accGetAll(accExt, accValueH, accValueL);
//
//
//        // Before the accumulator contains the wanted number of samples: Save the accumulator value to
//        // state.pAccValueBuffer[], so it can be restored in the next iteration
//        if (accSampleCount != (SAMPLE_SZ - 1)) {
//            *(pAccValueBuffer++) = accValueL;
//            *(pAccValueBuffer++) = accValueH;
//            pAccValueBuffer -= 2;
//
//        // When the accumulator contains the wanted number of samples: Save the accumulator value to
//        // output.pAccValueBuffer[] instead, so it can be handed over to the System CPU application
//        } else{
//            if (state.invalid != 1) {
//                if(input.canTouchTester==1){
//
//                }
//            }
//            *(pAccValueBuffer++) = accValueL;
//            *(pAccValueBuffer++) = accValueH;
//            pAccValueBuffer -= 2;
//
//        }
//
//        n += 1;
//        accSampleCount+=1;
//
//    }//end of   while (n < MULTI_BUFFER_SIZE) {
//
//    if(state.invalid != 1){
//        if(state.alertEnabled == 1) {
//            if(input.canTouchTester==1){
//            state.alertEnabled = 0;
//            input.canTouchTester=0;
//             U16 accValueL = *(pAccValueBuffer++);
//            U16 accValueH = *(pAccValueBuffer++);
//             pAccValueBuffer -= 2;
//                 pAccValueBuffer += accValueBufferOutputOffset; //move to output struct
//                *(pAccValueBuffer++) = accValueL;
//                *(pAccValueBuffer++) = accValueH;
//                pAccValueBuffer -= 2;
//                pAccValueBuffer -= accValueBufferOutputOffset; //move back to state struct
//            n=state.channelsIdx;
//            output.TxDetMin[n]=state.TxDetMin[n];
//            output.TxDetMax[n]=state.TxDetMax[n];
//            fwGenQuickAlertInterrupt();
//
//           state.TxDetMin[n]=65535;
//           state.TxDetMax[n]=0;
//
//        }
//    }
//    }
//
//
//    // reset all variables and decalre the rest of necessary variables
//    n = 0;
//


}
// trigger event A
evhSetupTimer0Trigger(0, 1, 2);]]></sccode>
        <sccode name="event3" init_power_mode="0"><![CDATA[]]></sccode>
        <sccode name="execute" init_power_mode="0"><![CDATA[]]></sccode>
        <sccode name="initialize" init_power_mode="0"><![CDATA[//immediately start event A code
evhSetupTimer0Trigger(0, 1, 0);]]></sccode>
        <sccode name="terminate" init_power_mode="0"><![CDATA[// cancel events trigger on termination
evhCancelTrigger(0);
evhCancelTrigger(1);
evhCancelTrigger(2);]]></sccode>
        <event_trigger active_count="3">0,1,2,3</event_trigger>
        <tt_iter>run_event0,run_event1,run_event2</tt_iter>
        <tt_struct>output.TxDetMax.[0],output.TxDetMax.[1],output.TxDetMax.[2],output.TxDetMax.[3],output.TxDetMin.[0],output.TxDetMin.[1],output.TxDetMin.[2],output.TxDetMin.[3],output.pAccValueBuffer.[0],output.pAccValueBuffer.[1],output.pAccValueBuffer.[2],output.pAccValueBuffer.[3],output.pAccValueBuffer.[4],output.pAccValueBuffer.[5],output.pAccValueBuffer.[6],output.pAccValueBuffer.[7],state.pAccValueBuffer.[0],state.pAccValueBuffer.[1],state.pAccValueBuffer.[2],state.pAccValueBuffer.[3],state.pAccValueBuffer.[4],state.pAccValueBuffer.[5],state.pAccValueBuffer.[6],state.pAccValueBuffer.[7],state.pAccValueBuffer.[8],state.pAccValueBuffer.[9],state.pAccValueBuffer.[10],state.pAccValueBuffer.[11],state.pAccValueBuffer.[12],state.pAccValueBuffer.[13],state.pAccValueBuffer.[14],state.pAccValueBuffer.[15],state.pAccValueBuffer.[16],state.pAccValueBuffer.[17],state.pAccValueBuffer.[18],state.pAccValueBuffer.[19],state.pAccValueBuffer.[20],state.pAccValueBuffer.[21],state.pAccValueBuffer.[22],state.pAccValueBuffer.[23],state.pAccValueBuffer.[24],state.pAccValueBuffer.[25],state.pAccValueBuffer.[26],state.pAccValueBuffer.[27],state.pAccValueBuffer.[28],state.pAccValueBuffer.[29],state.pAccValueBuffer.[30],state.pAccValueBuffer.[31]</tt_struct>
        <rtl_struct>cfg.tddMode</rtl_struct>
        <rtl_task_sel en="1" struct_log_list="output,cfg"/>
    </task>
</project>
