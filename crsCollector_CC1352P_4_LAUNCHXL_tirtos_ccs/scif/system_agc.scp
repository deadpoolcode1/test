<?xml version="1.0" encoding="UTF-8"?>
<project name="System AGC" version="2.9.0.208">
    <desc><![CDATA[Samples 4 channels for TX/RX voltage, calculates min and max values of these measures for each channel and raises AlertInterrupt for main application when done.
Sampling occurs only when TDD is locked and connected to the configured GPIO pins.]]></desc>
    <pattr name="Apply default power mode">0</pattr>
    <pattr name="Board">CC1352P* LaunchPad</pattr>
    <pattr name="Chip name">CC1352P1F3</pattr>
    <pattr name="Chip package">QFN48 7x7 RGZ</pattr>
    <pattr name="Chip revision">E</pattr>
    <pattr name="Clock in active mode">0</pattr>
    <pattr name="Code prefix"></pattr>
    <pattr name="Default power mode">0</pattr>
    <pattr name="Operating system">TI-RTOS</pattr>
    <pattr name="Output directory">C:/Users/epc_5/workspace/crs_tirtos_test/crsCollector_CC1352P_4_LAUNCHXL_tirtos_ccs/scif</pattr>
    <pattr name="RTC tick interval (16.16 format)">2000</pattr>
    <pattr name="Run-time logging UART RX pin"></pattr>
    <pattr name="Run-time logging UART TX pin"></pattr>
    <task name="System AGC">
        <desc><![CDATA[Samples 4 channels for TX/RX voltage, calculates min and max values of these measures for each channel and raises AlertInterrupt for main application when done.
Sampling occurs only when TDD is locked and connected to the configured GPIO pins.]]></desc>
        <tattr name="BUFFER_SIZE" desc="ADC measures buffer size for each cahnnel" type="expr" content="const" scope="task" min="0" max="65535">20</tattr>
        <tattr name="CHANNELS_NUMBER" desc="Number of channels to measure" type="expr" content="const" scope="task" min="0" max="65535">4</tattr>
        <tattr name="MODES_CHANNEL_SIZE" desc="The number of top 20% results from each channel" type="expr" content="const" scope="task" min="0" max="65535">MODES_SIZE / CHANNELS_NUMBER</tattr>
        <tattr name="MODES_SIZE" desc="Top 20% of results from the samples" type="expr" content="const" scope="task" min="0" max="65535">(MULTI_RESULT_SIZE / 10) * 2</tattr>
        <tattr name="MULTI_BUFFER_SIZE" desc="Number of measures from all channels in each  sample cycle" type="expr" content="const" scope="task" min="0" max="65535">BUFFER_SIZE * CHANNELS_NUMBER</tattr>
        <tattr name="MULTI_RESULT_SIZE" desc="Total number of measures from all  channels across all samples" type="expr" content="const" scope="task" min="0" max="65535">SAMPLE_SIZE*MULTI_BUFFER_SIZE</tattr>
        <tattr name="RESULTS" desc="Number of measures for a channel in a sample cycle." type="expr" content="const" scope="task" min="0" max="65535">BUFFER_SIZE*SAMPLE_SIZE</tattr>
        <tattr name="SAMPLE_SIZE" desc="Number of samples cycles." type="expr" content="const" scope="task" min="0" max="65535">3</tattr>
        <tattr name="cfg.channelsNum" desc="number of channels" type="expr" content="struct" scope="task" min="0" max="65535">CHANNELS_NUMBER</tattr>
        <tattr name="cfg.channelsSwitch" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="cfg.measuresCount" type="expr" content="struct" scope="task" min="0" max="65535">BUFFER_SIZE</tattr>
        <tattr name="cfg.modesChannel" type="expr" content="struct" scope="task" min="0" max="65535">MODES_CHANNEL_SIZE</tattr>
        <tattr name="cfg.samplesCount" desc="ALERT interrupt generation threshold" type="expr" content="struct" scope="task" min="0" max="65535">SAMPLE_SIZE</tattr>
        <tattr name="cfg.samplesNum" type="expr" content="struct" scope="task" min="0" max="65535">SAMPLE_SIZE</tattr>
        <tattr name="cfg.tddMode" desc="0 - ManualDL 1 - ManualUL 2 - Auto" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="cfg.unitType" desc="Type of unit - 0 : CDU, 1: CRU" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="input.randomDelayRX" size="SAMPLE_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="input.randomDelayTX" size="SAMPLE_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.channelsMaxIFRX" size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.channelsMaxIFTX" size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.channelsMaxRFRX" size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.channelsMaxRFTX" size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.channelsMinIFRX" size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.channelsMinIFTX" size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.channelsMinRFRX" size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.channelsMinRFTX" size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.maxSamplesIFRX" size="MODES_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.maxSamplesIFTX" size="MODES_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.maxSamplesRFRX" size="MODES_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.maxSamplesRFTX" size="MODES_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.minSamplesIFRX" size="MODES_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">65535</tattr>
        <tattr name="output.minSamplesIFTX" size="MODES_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">65535</tattr>
        <tattr name="output.minSamplesRFRX" size="MODES_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">65535</tattr>
        <tattr name="output.minSamplesRFTX" size="MODES_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">65535</tattr>
        <tattr name="output.pSamplesMultiChannelIF" size="MULTI_BUFFER_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.pSamplesMultiChannelRF" size="MULTI_BUFFER_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.alertEnabled" desc="Is ALERT interrupt generation enabled?" type="dec" content="struct" scope="task" min="0" max="65535">1</tattr>
        <tattr name="state.exit" desc="Set to exit the ADC data streamer" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.head" desc="ADC sample buffer (input) head index" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.ledCounter" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.tail" desc="ADC sample buffer (output) tail index" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.tddMode" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <resource_ref name="ADC" enabled="1"/>
        <resource_ref name="AON Domain Functionality" enabled="0"/>
        <resource_ref name="Accumulator-Based Math" enabled="1"/>
        <resource_ref name="Analog Open-Drain Pins" enabled="0"/>
        <resource_ref name="Analog Open-Source Pins" enabled="0"/>
        <resource_ref name="Analog Pins" enabled="1">
            <io_usage name="SENSOR_OUTPUT" label="Analog sensor output">
                <uattr name="Pin count">3</uattr>
                <uattr name="Pin/0000">DIO24</uattr>
                <uattr name="Pin/0001">DIO23</uattr>
                <uattr name="Pin/0002">DIO25</uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
            </io_usage>
        </resource_ref>
        <resource_ref name="COMPA" enabled="0"/>
        <resource_ref name="COMPA Event Trigger" enabled="0"/>
        <resource_ref name="COMPB" enabled="0"/>
        <resource_ref name="COMPB Event Trigger" enabled="0"/>
        <resource_ref name="Delay Insertion" enabled="1"/>
        <resource_ref name="Differential Output Pins" enabled="0"/>
        <resource_ref name="Digital Input Pins" enabled="1">
            <io_usage name="TDD_LOCK" label="TDD lock pin">
                <uattr name="Configuration on initialization">-1</uattr>
                <uattr name="Configuration on uninitialization">-1</uattr>
                <uattr name="Pin count">0</uattr>
                <uattr name="Pin/0000">DIO15</uattr>
                <uattr name="Pin/0001"></uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
                <uattr name="Pin/0008"></uattr>
                <uattr name="Pin/0009"></uattr>
                <uattr name="Pin/0010"></uattr>
                <uattr name="Pin/0011"></uattr>
                <uattr name="Pin/0012"></uattr>
                <uattr name="Pin/0013"></uattr>
                <uattr name="Pin/0014"></uattr>
                <uattr name="Pin/0015"></uattr>
                <uattr name="Pin/0016"></uattr>
                <uattr name="Pin/0017"></uattr>
                <uattr name="Pin/0018"></uattr>
                <uattr name="Pin/0019"></uattr>
                <uattr name="Pin/0020"></uattr>
                <uattr name="Pin/0021"></uattr>
                <uattr name="Pin/0022"></uattr>
                <uattr name="Pin/0023"></uattr>
                <uattr name="Pin/0024"></uattr>
                <uattr name="Pin/0025"></uattr>
                <uattr name="Pin/0026"></uattr>
                <uattr name="Pin/0027"></uattr>
                <uattr name="Pin/0028"></uattr>
                <uattr name="Pin/0029"></uattr>
                <uattr name="Pin/0030"></uattr>
                <uattr name="Pin/0031"></uattr>
            </io_usage>
            <io_usage name="TDD_SYNCH" label="TDD synchronization pin">
                <uattr name="Configuration on initialization">0</uattr>
                <uattr name="Configuration on uninitialization">-1</uattr>
                <uattr name="Pin count">0</uattr>
                <uattr name="Pin/0000">DIO14</uattr>
                <uattr name="Pin/0001"></uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
                <uattr name="Pin/0008"></uattr>
                <uattr name="Pin/0009"></uattr>
                <uattr name="Pin/0010"></uattr>
                <uattr name="Pin/0011"></uattr>
                <uattr name="Pin/0012"></uattr>
                <uattr name="Pin/0013"></uattr>
                <uattr name="Pin/0014"></uattr>
                <uattr name="Pin/0015"></uattr>
                <uattr name="Pin/0016"></uattr>
                <uattr name="Pin/0017"></uattr>
                <uattr name="Pin/0018"></uattr>
                <uattr name="Pin/0019"></uattr>
                <uattr name="Pin/0020"></uattr>
                <uattr name="Pin/0021"></uattr>
                <uattr name="Pin/0022"></uattr>
                <uattr name="Pin/0023"></uattr>
                <uattr name="Pin/0024"></uattr>
                <uattr name="Pin/0025"></uattr>
                <uattr name="Pin/0026"></uattr>
                <uattr name="Pin/0027"></uattr>
                <uattr name="Pin/0028"></uattr>
                <uattr name="Pin/0029"></uattr>
                <uattr name="Pin/0030"></uattr>
                <uattr name="Pin/0031"></uattr>
            </io_usage>
        </resource_ref>
        <resource_ref name="Digital Open-Drain Pins" enabled="0"/>
        <resource_ref name="Digital Open-Source Pins" enabled="0"/>
        <resource_ref name="Digital Output Pins" enabled="1">
            <io_usage name="CHANNEL_CONTROL" label="Channel control PINS">
                <uattr name="Configuration on uninitialization">-1</uattr>
                <uattr name="Output drive strength">0</uattr>
                <uattr name="Output value on initialization">0</uattr>
                <uattr name="Pin count">2</uattr>
                <uattr name="Pin/0000">DIO26</uattr>
                <uattr name="Pin/0001">DIO27</uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
                <uattr name="Pin/0008"></uattr>
                <uattr name="Pin/0009"></uattr>
                <uattr name="Pin/0010"></uattr>
                <uattr name="Pin/0011"></uattr>
                <uattr name="Pin/0012"></uattr>
                <uattr name="Pin/0013"></uattr>
                <uattr name="Pin/0014"></uattr>
                <uattr name="Pin/0015"></uattr>
                <uattr name="Pin/0016"></uattr>
                <uattr name="Pin/0017"></uattr>
                <uattr name="Pin/0018"></uattr>
                <uattr name="Pin/0019"></uattr>
                <uattr name="Pin/0020"></uattr>
                <uattr name="Pin/0021"></uattr>
                <uattr name="Pin/0022"></uattr>
                <uattr name="Pin/0023"></uattr>
                <uattr name="Pin/0024"></uattr>
                <uattr name="Pin/0025"></uattr>
                <uattr name="Pin/0026"></uattr>
                <uattr name="Pin/0027"></uattr>
                <uattr name="Pin/0028"></uattr>
                <uattr name="Pin/0029"></uattr>
                <uattr name="Pin/0030"></uattr>
                <uattr name="Pin/0031"></uattr>
            </io_usage>
            <io_usage name="RED_LED" label="Controls the red LED">
                <uattr name="Configuration on uninitialization">-1</uattr>
                <uattr name="Output drive strength">0</uattr>
                <uattr name="Output value on initialization">0</uattr>
                <uattr name="Pin count">0</uattr>
                <uattr name="Pin/0000">DIO6</uattr>
                <uattr name="Pin/0001"></uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
                <uattr name="Pin/0008"></uattr>
                <uattr name="Pin/0009"></uattr>
                <uattr name="Pin/0010"></uattr>
                <uattr name="Pin/0011"></uattr>
                <uattr name="Pin/0012"></uattr>
                <uattr name="Pin/0013"></uattr>
                <uattr name="Pin/0014"></uattr>
                <uattr name="Pin/0015"></uattr>
                <uattr name="Pin/0016"></uattr>
                <uattr name="Pin/0017"></uattr>
                <uattr name="Pin/0018"></uattr>
                <uattr name="Pin/0019"></uattr>
                <uattr name="Pin/0020"></uattr>
                <uattr name="Pin/0021"></uattr>
                <uattr name="Pin/0022"></uattr>
                <uattr name="Pin/0023"></uattr>
                <uattr name="Pin/0024"></uattr>
                <uattr name="Pin/0025"></uattr>
                <uattr name="Pin/0026"></uattr>
                <uattr name="Pin/0027"></uattr>
                <uattr name="Pin/0028"></uattr>
                <uattr name="Pin/0029"></uattr>
                <uattr name="Pin/0030"></uattr>
                <uattr name="Pin/0031"></uattr>
            </io_usage>
            <io_usage name="GREEN_LED" label="Controls the green LED">
                <uattr name="Configuration on uninitialization">-1</uattr>
                <uattr name="Output drive strength">0</uattr>
                <uattr name="Output value on initialization">0</uattr>
                <uattr name="Pin count">0</uattr>
                <uattr name="Pin/0000">DIO7</uattr>
                <uattr name="Pin/0001"></uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
                <uattr name="Pin/0008"></uattr>
                <uattr name="Pin/0009"></uattr>
                <uattr name="Pin/0010"></uattr>
                <uattr name="Pin/0011"></uattr>
                <uattr name="Pin/0012"></uattr>
                <uattr name="Pin/0013"></uattr>
                <uattr name="Pin/0014"></uattr>
                <uattr name="Pin/0015"></uattr>
                <uattr name="Pin/0016"></uattr>
                <uattr name="Pin/0017"></uattr>
                <uattr name="Pin/0018"></uattr>
                <uattr name="Pin/0019"></uattr>
                <uattr name="Pin/0020"></uattr>
                <uattr name="Pin/0021"></uattr>
                <uattr name="Pin/0022"></uattr>
                <uattr name="Pin/0023"></uattr>
                <uattr name="Pin/0024"></uattr>
                <uattr name="Pin/0025"></uattr>
                <uattr name="Pin/0026"></uattr>
                <uattr name="Pin/0027"></uattr>
                <uattr name="Pin/0028"></uattr>
                <uattr name="Pin/0029"></uattr>
                <uattr name="Pin/0030"></uattr>
                <uattr name="Pin/0031"></uattr>
            </io_usage>
        </resource_ref>
        <resource_ref name="Dynamic Power Control" enabled="0"/>
        <resource_ref name="GPIO Event Trigger" enabled="1"/>
        <resource_ref name="I2C Master" enabled="0">
            <rattr name="SCL frequency">0</rattr>
            <rattr name="SCL stretch timeout">1</rattr>
            <io_usage>
                <uattr name="Output drive strength">1</uattr>
                <uattr name="SCL pin/0000"></uattr>
                <uattr name="SDA pin/0000"></uattr>
            </io_usage>
        </resource_ref>
        <resource_ref name="ISRC" enabled="0"/>
        <resource_ref name="LCD Controller" enabled="0">
            <rattr name="Waveform state count">8</rattr>
            <io_usage>
                <uattr name="Output drive strength">0</uattr>
                <uattr name="Pin count">20</uattr>
                <uattr name="Pin/0000"></uattr>
                <uattr name="Pin/0001"></uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
                <uattr name="Pin/0008"></uattr>
                <uattr name="Pin/0009"></uattr>
                <uattr name="Pin/0010"></uattr>
                <uattr name="Pin/0011"></uattr>
                <uattr name="Pin/0012"></uattr>
                <uattr name="Pin/0013"></uattr>
                <uattr name="Pin/0014"></uattr>
                <uattr name="Pin/0015"></uattr>
                <uattr name="Pin/0016"></uattr>
                <uattr name="Pin/0017"></uattr>
                <uattr name="Pin/0018"></uattr>
                <uattr name="Pin/0019"></uattr>
                <uattr name="Pin/0020"></uattr>
                <uattr name="Pin/0021"></uattr>
                <uattr name="Pin/0022"></uattr>
                <uattr name="Pin/0023"></uattr>
                <uattr name="Pin/0024"></uattr>
                <uattr name="Pin/0025"></uattr>
                <uattr name="Pin/0026"></uattr>
                <uattr name="Pin/0027"></uattr>
                <uattr name="Pin/0028"></uattr>
                <uattr name="Pin/0029"></uattr>
                <uattr name="Pin/0030"></uattr>
                <uattr name="Pin/0031"></uattr>
            </io_usage>
        </resource_ref>
        <resource_ref name="Math and Logic" enabled="1"/>
        <resource_ref name="Multi-Buffered Output Data Exchange" enabled="0">
            <rattr name="Buffer count">2</rattr>
            <rattr name="Indicate overflow at buffer check">0</rattr>
            <rattr name="Indicate overflow at buffer switch">0</rattr>
            <rattr name="Prevent overflow at buffer switch">0</rattr>
        </resource_ref>
        <resource_ref name="Peripheral Sharing" enabled="0"/>
        <resource_ref name="Pulse Counter" enabled="0"/>
        <resource_ref name="RTC Multi-Event Capture" enabled="0"/>
        <resource_ref name="RTC-Based Execution Scheduling" enabled="0"/>
        <resource_ref name="Reference DAC" enabled="0"/>
        <resource_ref name="Run-Time Logging" enabled="1"/>
        <resource_ref name="SPI Chip Select" enabled="0"/>
        <resource_ref name="SPI Data Transfer" enabled="0">
            <rattr name="Bit rate">0</rattr>
            <rattr name="MISO configuration when inactive">-1</rattr>
            <rattr name="MOSI configuration on initialization">0</rattr>
            <rattr name="MOSI configuration on uninitialization">0</rattr>
            <rattr name="SCLK configuration on initialization">0</rattr>
            <rattr name="SCLK configuration on uninitialization">0</rattr>
            <io_usage>
                <uattr name="MISO pin/0000"></uattr>
                <uattr name="MOSI pin/0000"></uattr>
                <uattr name="SCLK pin/0000"></uattr>
            </io_usage>
        </resource_ref>
        <resource_ref name="Signal Observation" enabled="0"/>
        <resource_ref name="System CPU Alert" enabled="1"/>
        <resource_ref name="System Event Trigger" enabled="0"/>
        <resource_ref name="TDC" enabled="0"/>
        <resource_ref name="Timer 0" enabled="0"/>
        <resource_ref name="Timer 0 Event Trigger" enabled="1"/>
        <resource_ref name="Timer 1" enabled="1"/>
        <resource_ref name="Timer 1 Event Trigger" enabled="0"/>
        <resource_ref name="Timer 2" enabled="0"/>
        <resource_ref name="Timer 2 Event Trigger" enabled="0"/>
        <resource_ref name="UART Emulator" enabled="0">
            <rattr name="RX buffer size">64</rattr>
            <rattr name="Required idle period before enabling RX">11</rattr>
            <rattr name="TX buffer size">64</rattr>
            <io_usage>
                <uattr name="RX pin/0000"></uattr>
                <uattr name="TX pin/0000"></uattr>
            </io_usage>
        </resource_ref>
        <sccode name="event0" init_power_mode="0"><![CDATA[state.tddMode = cfg.tddMode;
if(state.tddMode == 2){
    if(state.ledCounter == 0){
        gpioClearOutput(AUXIO_O_RED_LED);
        gpioClearOutput(AUXIO_O_GREEN_LED);
    }
    if(state.ledCounter >= 50){
        gpioClearOutput(AUXIO_O_RED_LED);
        gpioClearOutput(AUXIO_O_GREEN_LED);
        state.ledCounter = 0;
    }
    state.ledCounter += 1;
    evhSetupGpioTrigger(1, AUXIO_I_TDD_SYNCH, 1, EVH_GPIO_TRIG_ON_EDGE); // for tdd lock pin
    evhSetupTimer0Trigger(0, 100, 2);
}else{
    //if(state.tddMode == 0){
    //    state.tddMode = 1;
    //}else{
    //    state.tddMode = 0;
    //}
    evhSetupTimer0Trigger(1, 1, 2);
}
//evhSetupGpioTrigger(1, AUXIO_I_TDD_SYNCH, 1, EVH_GPIO_TRIG_ON_MATCH);]]></sccode>
        <sccode name="event1" init_power_mode="0"><![CDATA[if(state.tddMode != 1){
    // randomDelay between 0 to 500 microsecond, is delivered by application.
    if(state.tddMode == 2){
        if(state.ledCounter < 25){
            gpioClearOutput(AUXIO_O_RED_LED);
            gpioSetOutput(AUXIO_O_GREEN_LED);
        }
    }else{
        gpioClearOutput(AUXIO_O_RED_LED);
        gpioSetOutput(AUXIO_O_GREEN_LED);
    }
    U16 n = 0;
    n = cfg.samplesCount;
    fwDelayUs(input.randomDelayRX[n]);

    // Select ADC input
    //adcSelectGpioInput(AUXIO_A_SENSOR_OUTPUT);

    // Enable the ADC
    adcEnableSync(ADC_REF_FIXED, ADC_SAMPLE_TIME_2P7_US, ADC_TRIGGER_MANUAL); // manual sampling, 2.7 us sample time
    //adcEnableAsync(ADC_REF_FIXED, ADC_TRIGGER_MANUAL);
    //timer0Start(TIMER0_MODE_PERIODICAL, 120, 0);

    // Initialize variables, only 6 are available
    U16 a = 0;
    S16 b = 0;
    U16 c = 0;
    U16 d = 0;
    U16 e = 0;
    U16 f = 0;

    // 2.7 sample time, 3 pins, 4 channels.
    // 2.7 us for each channel. 2.7 * 4 = 10.8 us sampling rate on PIN.

    n = 0;
    while (n < MULTI_BUFFER_SIZE) {
        if(cfg.unitType == 1){
            gpioClearOutput(cfg.pAuxioOChannelControl[0]);
            gpioClearOutput(cfg.pAuxioOChannelControl[1]);
        }else{
            gpioSetOutput(cfg.pAuxioOChannelControl[0]);
            gpioSetOutput(cfg.pAuxioOChannelControl[1]);
        }
        if(cfg.channelsSwitch == 2){
            if(cfg.unitType == 1){
                gpioSetOutput(cfg.pAuxioOChannelControl[0]);
            }else{
                gpioClearOutput(cfg.pAuxioOChannelControl[0]);
            }
        }
        if(cfg.channelsSwitch == 3){
            if(cfg.unitType == 1){
                gpioSetOutput(cfg.pAuxioOChannelControl[1]);
            }else{
                gpioClearOutput(cfg.pAuxioOChannelControl[1]);
            }
        }
        if(cfg.channelsSwitch == 4){
            if(cfg.unitType == 1){
                gpioSetOutput(cfg.pAuxioOChannelControl[0]);
                gpioSetOutput(cfg.pAuxioOChannelControl[1]);
            }else{
                gpioClearOutput(cfg.pAuxioOChannelControl[0]);
                gpioClearOutput(cfg.pAuxioOChannelControl[1]);
            }
        }
        while(a < cfg.channelsNum){
            // Select channel
            // a = channel
            if(cfg.unitType == 0){
                adcSelectGpioInput(cfg.pAuxioASensorOutput[0]);
            }else{
                adcSelectGpioInput(cfg.pAuxioASensorOutput[1]);
            }
            adcGenManualTrigger();
            adcReadFifo(output.pSamplesMultiChannelRF[n]);
            adcSelectGpioInput(cfg.pAuxioASensorOutput[2]);
            adcGenManualTrigger();
            adcReadFifo(output.pSamplesMultiChannelIF[n]);
            n += 1;
            a += 1; // select channel with gpio pins
            if(cfg.channelsSwitch == 0){
                if(a == 1){
                    if(cfg.unitType == 1){
                        gpioSetOutput(cfg.pAuxioOChannelControl[0]);
                        gpioClearOutput(cfg.pAuxioOChannelControl[1]);
                    }else{
                        gpioClearOutput(cfg.pAuxioOChannelControl[0]);
                        gpioSetOutput(cfg.pAuxioOChannelControl[1]);
                    }
                }
                if (a == 2){
                    if(cfg.unitType == 1){
                        gpioClearOutput(cfg.pAuxioOChannelControl[0]);
                        gpioSetOutput(cfg.pAuxioOChannelControl[1]);
                    }else{
                        gpioSetOutput(cfg.pAuxioOChannelControl[0]);
                        gpioClearOutput(cfg.pAuxioOChannelControl[1]);
                    }
                }
                if (a == 3){
                    if(cfg.unitType == 1){
                        gpioSetOutput(cfg.pAuxioOChannelControl[0]);
                        gpioSetOutput(cfg.pAuxioOChannelControl[1]);
                    }else{
                        gpioClearOutput(cfg.pAuxioOChannelControl[0]);
                        gpioClearOutput(cfg.pAuxioOChannelControl[1]);
                    }
                }
            }

        }
        a = 0;
    }
    // Disable the ADC
    adcDisable();

    a = 0;
    b = 0;
    c = 0;
    n = 0;
    f = 0;
    // get top and bottom 20% of results from samples.
    while(f < cfg.channelsNum){
        while(n<BUFFER_SIZE){
            c = n;
            accMul16s16u(n, cfg.channelsNum);
            accGet16(0; n);
            n += f;
            a = output.pSamplesMultiChannelRF[n];
            b = MODES_CHANNEL_SIZE - 1;
            // check if smaple is greaer than any of the samples in maxmodes
            while( b >= 0){
                accMul16s16u(f, MODES_CHANNEL_SIZE);
                accGet16(0; n);
                n += b;
                d = output.maxSamplesRFRX[n];
                if(d < a){
                    output.maxSamplesRFRX[n] = a;
                    while(0 < b){
                        n -= 1;
                        b -= 1;
                        e = output.maxSamplesRFRX[n];
                        output.maxSamplesRFRX[n] = d;
                        d = e;
                    }
                    b = 0; // so b will be below 0 and loop will break
                }
                b -=1;
            }

            b = 0;
            // check if smaple is lesser than any of the samples in minmodes
            while( b < MODES_CHANNEL_SIZE){
                accMul16s16u(f, MODES_CHANNEL_SIZE);
                accGet16(0; n);
                n += b;
                d = output.minSamplesRFRX[n];
                if(d > a){
                    output.minSamplesRFRX[n] = a;
                    while(b < (MODES_CHANNEL_SIZE-1)){
                        n += 1;
                        b += 1;
                        e = output.minSamplesRFRX[n];
                        output.minSamplesRFRX[n] = d;
                        d = e;
                    }
                    b = MODES_CHANNEL_SIZE; // so loop will break
                }
                b +=1;
            }

            n = c;
            accMul16s16u(n, cfg.channelsNum);
            accGet16(0; n);
            n += f;
            a = output.pSamplesMultiChannelIF[n];
            b = MODES_CHANNEL_SIZE - 1;

            while(b >= 0){
                accMul16s16u(f, MODES_CHANNEL_SIZE);
                accGet16(0; n);
                n += b;
                d = output.maxSamplesIFRX[n];
                if(d < a){
                    output.maxSamplesIFRX[n] = a;
                    while(0 < b){
                        n -= 1;
                        b -= 1;
                        e = output.maxSamplesIFRX[n];
                        output.maxSamplesIFRX[n] = d;
                        d = e;
                    }
                    b = 0; // so loop will break
                }
                b -=1;
            }

            b = 0;
            // check if smaple is lesser than any of the samples in minmodes
            while( b < MODES_CHANNEL_SIZE){
                accMul16s16u(f, MODES_CHANNEL_SIZE);
                accGet16(0; n);
                n += b;
                d = output.minSamplesIFRX[n];
                if(d > a){
                    output.minSamplesIFRX[n] = a;
                    while(b < (MODES_CHANNEL_SIZE-1)){
                        n += 1;
                        b += 1;
                        e = output.minSamplesIFRX[n];
                        output.minSamplesIFRX[n] = d;
                        d = e;
                    }
                    b = MODES_CHANNEL_SIZE; // so loop will break
                }
                b +=1;
            }

            n = c;
            n += 1;
        }
        n = 0;
        f += 1;

    }

    cfg.samplesCount -= 1;

    n = 0;
    a = 0;
    b = 0;
    c = 0;
    d = 0;
    e = 0;
    f = 0;
    // after 5 cycles of measures
    if(cfg.samplesCount == 0){

        // we now have in output.maxSamples array with top 20% of results for each channel. channel0, channel1...
        // from the top 20% results we sort by ranges for each channel to determine which range has most results

        // clear values in Samples arrays
        while(n<CHANNELS_NUMBER){
            output.channelsMaxRFRX[n] = 0;
            output.channelsMaxIFRX[n] = 0;
            output.channelsMinRFRX[n] = 0;
            output.channelsMinIFRX[n] = 0;
            n +=1;
        }

        n = 0;
        while(f<cfg.channelsNum){
            while(a<MODES_CHANNEL_SIZE){
                b = n;
                c = output.maxSamplesRFRX[n];
                d = output.maxSamplesIFRX[n];
                n = f;
                output.channelsMaxRFRX[n] += c;
                output.channelsMaxIFRX[n] += d;

                n = b;
                c = output.minSamplesRFRX[n];
                d = output.minSamplesIFRX[n];
                n = f;
                output.channelsMinRFRX[n] += c;
                output.channelsMinIFRX[n] += d;

                n = b;
                a+=1;
                n+=1;
            }
            a = 0;
            f += 1;
        }

        // clear values in modes arrays
        n = 0;
        while(n<MODES_SIZE){
            output.maxSamplesRFRX[n] = 0;
            output.maxSamplesIFRX[n] = 0;
            output.minSamplesRFRX[n] = 65535;
            output.minSamplesIFRX[n] = 65535;
            n += 1;
        }
        n = 0;
        if(state.tddMode == 0){
            cfg.samplesCount = SAMPLE_SIZE;
            rtlLogStructs(BV_RTL_LOG_OUTPUT);
            // if interrupt flag is enabled, raises the interrupt for application to process results
            if(state.alertEnabled == 1) {
                state.alertEnabled = 0;
                fwGenQuickAlertInterrupt();
            }
        }
    }


    // Stop the ADC trigger and flush the ADC FIFO
    //timer0Stop();
    //adcFlushFifo();


    // schedule the next task execution
    //evhSetupGpioTrigger(0, AUXIO_I_TDD_LOCK, 0, EVH_GPIO_TRIG_ON_MATCH);
    // for testing
    //fwScheduleTask(1);
    if(state.tddMode == 2){
        evhSetupGpioTrigger(2, AUXIO_I_TDD_SYNCH, 0, EVH_GPIO_TRIG_ON_EDGE);
        evhSetupTimer0Trigger(0, 100, 2);
    }else{
        evhSetupTimer0Trigger(2, 1, 2);
    }
}else{
    evhSetupTimer0Trigger(2, 1, 2);
}]]></sccode>
        <sccode name="event2" init_power_mode="0"><![CDATA[if(state.tddMode > 0){
    // randomDelay between 0 to 500 microsecond, is delivered by application.
    if(state.tddMode == 2){
        if(state.ledCounter > 25){
            gpioClearOutput(AUXIO_O_GREEN_LED);
            gpioSetOutput(AUXIO_O_RED_LED);
        }
    }else{
        gpioClearOutput(AUXIO_O_GREEN_LED);
        gpioSetOutput(AUXIO_O_RED_LED);
    }
    U16 n = 0;
    n = cfg.samplesCount;
    fwDelayUs(input.randomDelayTX[n]);

    // Select ADC input
    //adcSelectGpioInput(AUXIO_A_SENSOR_OUTPUT);

    // Enable the ADC
    adcEnableSync(ADC_REF_FIXED, ADC_SAMPLE_TIME_2P7_US, ADC_TRIGGER_MANUAL); // manual sampling, 2.7 us sample time
    //adcEnableAsync(ADC_REF_FIXED, ADC_TRIGGER_MANUAL);
    //timer0Start(TIMER0_MODE_PERIODICAL, 120, 0);

    // Initialize variables, only 6 are available
    U16 a = 0;
    S16 b = 0;
    U16 c = 0;
    U16 d = 0;
    U16 e = 0;
    U16 f = 0;

    // 2.7 sample time, 3 pins, 4 channels.
    // 2.7 us for each channel. 2.7 * 4 = 10.8 us sampling rate on PIN.

    n = 0;
    while (n < MULTI_BUFFER_SIZE) {
        if(cfg.unitType == 0){
            gpioClearOutput(cfg.pAuxioOChannelControl[0]);
            gpioClearOutput(cfg.pAuxioOChannelControl[1]);
        }else{
            gpioSetOutput(cfg.pAuxioOChannelControl[0]);
            gpioSetOutput(cfg.pAuxioOChannelControl[1]);
        }
        if(cfg.channelsSwitch == 2){
            if(cfg.unitType == 0){
                gpioSetOutput(cfg.pAuxioOChannelControl[0]);
            }else{
                gpioClearOutput(cfg.pAuxioOChannelControl[0]);
            }
        }
        if(cfg.channelsSwitch == 3){
            if(cfg.unitType == 0){
                gpioSetOutput(cfg.pAuxioOChannelControl[1]);
            }else{
                gpioClearOutput(cfg.pAuxioOChannelControl[1]);
            }
        }
        if(cfg.channelsSwitch == 4){
            if(cfg.unitType == 0){
                gpioSetOutput(cfg.pAuxioOChannelControl[0]);
                gpioSetOutput(cfg.pAuxioOChannelControl[1]);
            }else{
                gpioClearOutput(cfg.pAuxioOChannelControl[0]);
                gpioClearOutput(cfg.pAuxioOChannelControl[1]);
            }
        }
        while(a < cfg.channelsNum){
            // Select channel
            // a = channel
            if(cfg.unitType == 0){
                adcSelectGpioInput(cfg.pAuxioASensorOutput[1]);
            }else{
                adcSelectGpioInput(cfg.pAuxioASensorOutput[0]);
            }
            adcGenManualTrigger();
            adcReadFifo(output.pSamplesMultiChannelRF[n]);
            adcSelectGpioInput(cfg.pAuxioASensorOutput[2]);
            adcGenManualTrigger();
            adcReadFifo(output.pSamplesMultiChannelIF[n]);
            n += 1;
            a += 1; // select channel with gpio pins
            if(cfg.channelsSwitch == 0){
                if(a == 1){
                    if(cfg.unitType == 0){
                        gpioSetOutput(cfg.pAuxioOChannelControl[0]);
                        gpioClearOutput(cfg.pAuxioOChannelControl[1]);
                    }else{
                        gpioClearOutput(cfg.pAuxioOChannelControl[0]);
                        gpioSetOutput(cfg.pAuxioOChannelControl[1]);
                    }
                }
                if (a == 2){
                    if(cfg.unitType == 0){
                        gpioClearOutput(cfg.pAuxioOChannelControl[0]);
                        gpioSetOutput(cfg.pAuxioOChannelControl[1]);
                    }else{
                        gpioSetOutput(cfg.pAuxioOChannelControl[0]);
                        gpioClearOutput(cfg.pAuxioOChannelControl[1]);
                    }
                }
                if (a == 3){
                    if(cfg.unitType == 0){
                        gpioSetOutput(cfg.pAuxioOChannelControl[0]);
                        gpioSetOutput(cfg.pAuxioOChannelControl[1]);
                    }else{
                        gpioClearOutput(cfg.pAuxioOChannelControl[0]);
                        gpioClearOutput(cfg.pAuxioOChannelControl[1]);
                    }
                }
            }

        }
        a = 0;
    }
    // Disable the ADC
    adcDisable();

    a = 0;
    b = 0;
    c = 0;
    n = 0;
    f = 0;
    // get top and bottom 20% of results from samples.
    while(f < cfg.channelsNum){
        while(n<BUFFER_SIZE){
            c = n;
            accMul16s16u(n, cfg.channelsNum);
            accGet16(0; n);
            n += f;
            a = output.pSamplesMultiChannelRF[n];
            b = MODES_CHANNEL_SIZE - 1;
            // check if smaple is greaer than any of the samples in maxmodes
            while( b >= 0){
                accMul16s16u(f, MODES_CHANNEL_SIZE);
                accGet16(0; n);
                n += b;
                d = output.maxSamplesRFTX[n];
                if(d < a){
                    output.maxSamplesRFTX[n] = a;
                    while(0 < b){
                        n -= 1;
                        b -= 1;
                        e = output.maxSamplesRFTX[n];
                        output.maxSamplesRFTX[n] = d;
                        d = e;
                    }
                    b = 0; // so b will be below 0 and loop will break
                }
                b -=1;
            }

            b = 0;
            // check if smaple is lesser than any of the samples in minmodes
            while( b < MODES_CHANNEL_SIZE){
                accMul16s16u(f, MODES_CHANNEL_SIZE);
                accGet16(0; n);
                n += b;
                d = output.minSamplesRFTX[n];
                if(d > a){
                    output.minSamplesRFTX[n] = a;
                    while(b < (MODES_CHANNEL_SIZE-1)){
                        n += 1;
                        b += 1;
                        e = output.minSamplesRFTX[n];
                        output.minSamplesRFTX[n] = d;
                        d = e;
                    }
                    b = MODES_CHANNEL_SIZE; // so loop will break
                }
                b +=1;
            }

            n = c;
            accMul16s16u(n, cfg.channelsNum);
            accGet16(0; n);
            n += f;
            a = output.pSamplesMultiChannelIF[n];
            b = MODES_CHANNEL_SIZE - 1;

            while(b >= 0){
                accMul16s16u(f, MODES_CHANNEL_SIZE);
                accGet16(0; n);
                n += b;
                d = output.maxSamplesIFTX[n];
                if(d < a){
                    output.maxSamplesIFTX[n] = a;
                    while(0 < b){
                        n -= 1;
                        b -= 1;
                        e = output.maxSamplesIFTX[n];
                        output.maxSamplesIFTX[n] = d;
                        d = e;
                    }
                    b = 0; // so loop will break
                }
                b -=1;
            }

            b = 0;
            // check if smaple is lesser than any of the samples in minmodes
            while( b < MODES_CHANNEL_SIZE){
                accMul16s16u(f, MODES_CHANNEL_SIZE);
                accGet16(0; n);
                n += b;
                d = output.minSamplesIFTX[n];
                if(d > a){
                    output.minSamplesIFTX[n] = a;
                    while(b < (MODES_CHANNEL_SIZE-1)){
                        n += 1;
                        b += 1;
                        e = output.minSamplesIFTX[n];
                        output.minSamplesIFTX[n] = d;
                        d = e;
                    }
                    b = MODES_CHANNEL_SIZE; // so loop will break
                }
                b +=1;
            }

            n = c;
            n += 1;
        }
        n = 0;
        f += 1;

    }

    if(state.tddMode == 1){
        cfg.samplesCount -= 1;
    }

    n = 0;
    a = 0;
    b = 0;
    c = 0;
    d = 0;
    e = 0;
    f = 0;
    // after 5 cycles of measures
    if(cfg.samplesCount == 0){

        // we now have in output.maxModes array with top 20% of results for each channel. channel0, channel1...
        // from the top 20% results we sort by ranges for each channel to determine which range has most results

        // clear values in modes arrays
        while(n<CHANNELS_NUMBER){
            output.channelsMaxRFTX[n] = 0;
            output.channelsMaxIFTX[n] = 0;
            output.channelsMinRFTX[n] = 0;
            output.channelsMinIFTX[n] = 0;
            n +=1;
        }

        n = 0;
        while(f<cfg.channelsNum){
            while(a<MODES_CHANNEL_SIZE){
                b = n;
                c = output.maxSamplesRFTX[n];
                d = output.maxSamplesIFTX[n];
                n = f;
                output.channelsMaxRFTX[n] += c;
                output.channelsMaxIFTX[n] += d;

                n = b;
                c = output.minSamplesRFTX[n];
                d = output.minSamplesIFTX[n];
                n = f;
                output.channelsMinRFTX[n] += c;
                output.channelsMinIFTX[n] += d;

                n = b;
                a+=1;
                n+=1;
            }
            a = 0;
            f += 1;
        }

        // clear values in modes arrays
        n = 0;
        while(n<MODES_SIZE){
            output.maxSamplesRFTX[n] = 0;
            output.maxSamplesIFTX[n] = 0;
            output.minSamplesRFTX[n] = 65535;
            output.minSamplesIFTX[n] = 65535;
            n += 1;
        }
        n = 0;
        cfg.samplesCount = SAMPLE_SIZE;
        rtlLogStructs(BV_RTL_LOG_OUTPUT);
        // if interrupt flag is enabled, raises the interrupt for application to process results
        if(state.alertEnabled == 1) {
            state.alertEnabled = 0;
            fwGenQuickAlertInterrupt();
        }
    }


    // Stop the ADC trigger and flush the ADC FIFO
    //timer0Stop();
    //adcFlushFifo();


    // schedule the next task execution
    //evhSetupGpioTrigger(0, AUXIO_I_TDD_LOCK, 0, EVH_GPIO_TRIG_ON_MATCH);
    // for testing
    //fwScheduleTask(1);
    adcDisable();
//    if(state.tddMode == 2){
//        evhSetupGpioTrigger(0, AUXIO_I_TDD_LOCK, 0, EVH_GPIO_TRIG_ON_MATCH);
//        //evhSetupGpioTrigger(0, AUXIO_I_TDD_SYNCH, 1, EVH_GPIO_TRIG_ON_EDGE);
//        evhSetupTimer0Trigger(0, 100, 2);
//    }else{
//        evhSetupTimer0Trigger(0, 1, 2);
//    }
    evhSetupTimer0Trigger(0, 1, 2);
}else{
    evhSetupTimer0Trigger(0, 1, 2);
}]]></sccode>
        <sccode name="event3" init_power_mode="0"><![CDATA[]]></sccode>
        <sccode name="execute" init_power_mode="0"><![CDATA[]]></sccode>
        <sccode name="initialize" init_power_mode="0"><![CDATA[state.tddMode = cfg.tddMode;
//if(state.tddMode == 2){
//    evhSetupGpioTrigger(0, AUXIO_I_TDD_LOCK, 0, EVH_GPIO_TRIG_ON_MATCH);
//    evhSetupTimer0Trigger(0, 100, 2);
//}else {
//    //timer0StartWithTickSrc(TIMER0_TICKSRC_AON_RTC_4KHZ, 1, TIMER0_MODE_PERIODICAL, 4096 / 20, 0);
//    //evhSetupTimer0CustomTrigger(1);
//    evhSetupTimer0Trigger(0, 1, 2);
//}
////evhSetupGpioTrigger(0, AUXIO_I_TDD_SYNCH, 1, EVH_GPIO_TRIG_ON_EDGE);
evhSetupTimer0Trigger(0, 1, 2);]]></sccode>
        <sccode name="terminate" init_power_mode="0"><![CDATA[]]></sccode>
        <event_trigger active_count="3">0,1,2,3</event_trigger>
        <tt_iter>run_event0,run_event1,run_event2</tt_iter>
        <tt_struct>output.channelsMinRFRX.[3],output.channelsMinRFTX.[0],output.channelsMinRFTX.[3]</tt_struct>
        <rtl_struct>cfg.tddMode</rtl_struct>
        <rtl_task_sel en="1" struct_log_list="output,cfg"/>
    </task>
</project>
