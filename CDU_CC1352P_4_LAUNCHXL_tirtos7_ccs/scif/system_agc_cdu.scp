<?xml version="1.0" encoding="UTF-8"?>
<project name="System AGC CDU CODE" version="2.9.0.208">
    <desc><![CDATA[Samples 4 channels for TX/RX voltage, calculates min and max values of these measures for each channel and raises AlertInterrupt for main application when done.
Sampling occurs only when TDD is locked and connected to the configured GPIO pins.]]></desc>
    <pattr name="Apply default power mode">0</pattr>
    <pattr name="Board">CC1352P* LaunchPad</pattr>
    <pattr name="Chip name">CC1352P1F3</pattr>
    <pattr name="Chip package">QFN48 7x7 RGZ</pattr>
    <pattr name="Chip revision">E</pattr>
    <pattr name="Clock in active mode">0</pattr>
    <pattr name="Code prefix"></pattr>
    <pattr name="Default power mode">0</pattr>
    <pattr name="Operating system">TI-RTOS</pattr>
    <pattr name="Output directory">C:/Users/cellium/workspace_v12/crs_tirtos_test/CDU_CC1352P_4_LAUNCHXL_tirtos7_ccs/scif</pattr>
    <pattr name="RTC tick interval (16.16 format)">2000</pattr>
    <pattr name="Run-time logging UART RX pin"></pattr>
    <pattr name="Run-time logging UART TX pin"></pattr>
    <task name="System AGC">
        <desc><![CDATA[Samples 4 channels for TX/RX voltage, calculates min and max values of these measures for each channel and raises AlertInterrupt for main application when done.
Sampling occurs only when TDD is locked and connected to the configured GPIO pins.]]></desc>
        <tattr name="ACC_VALUE_BUFFER_SIZE" desc="Size of the accumulator value buffers (one 32-bit value per ADC channel)" type="expr" content="const" scope="task" min="0" max="65535">CHANNEL_COUNT * 8</tattr>
        <tattr name="ADC_SAMPLE_RATE" desc="ADC sample rate, in Hz (divide by channel count to get sample rate per channel)" type="expr" content="const" scope="task" min="0" max="65535">100000</tattr>
        <tattr name="AVERAGE_SIZE" type="expr" content="const" scope="task" min="0" max="65535">20</tattr>
        <tattr name="BUFFER_SIZE" desc="Number of measures on each channel from one sample cycle (one DL/UL period)" type="expr" content="const" scope="task" min="0" max="65535">10</tattr>
        <tattr name="CHANNELS_NUMBER" desc="Number of channels" type="expr" content="const" scope="task" min="0" max="65535">4</tattr>
        <tattr name="CHANNEL_COUNT" desc="Number of ADC channels" type="expr" content="const" scope="task" min="0" max="65535">4</tattr>
        <tattr name="CHANNEL_HOLD_NUM" type="expr" content="const" scope="task" min="0" max="65535">4</tattr>
        <tattr name="SAMPLE_SIZE" desc="Number of sample cycles" type="expr" content="const" scope="task" min="0" max="65535">2</tattr>
        <tattr name="SAMPLE_SZ" type="expr" content="const" scope="task" min="0" max="65535">40</tattr>
        <tattr name="TP_CHANNEL_COUNT" type="expr" content="const" scope="task" min="0" max="65535">4</tattr>
        <tattr name="cfg.Dio26" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="cfg.Dio27" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="cfg.channelsSwitch" desc="Channel select - 0: measure all channels, 1 - 4: measure only this channel" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="cfg.eventCounter" desc="counts transitons number from event b(UL) to c(DL)" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="cfg.tddMode" desc="TDD mode - 0: Auto , 1: ManualDL, 2: ManualUL" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="input.Period1" desc="TDD env variable " type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="input.canTouchTester" type="expr" content="struct" scope="task" min="0" max="65535">1</tattr>
        <tattr name="input.gapStartRx" type="expr" content="struct" scope="task" min="0" max="65535">50</tattr>
        <tattr name="input.gapStartTx" type="expr" content="struct" scope="task" min="0" max="65535">50</tattr>
        <tattr name="input.gapStopRx" type="expr" content="struct" scope="task" min="0" max="65535">50</tattr>
        <tattr name="input.gapStopTx" type="expr" content="struct" scope="task" min="0" max="65535">50</tattr>
        <tattr name="input.randomDelayDL" size="SAMPLE_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="input.randomDelayUL" size="SAMPLE_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="input.tddLock" desc="TDD lock status" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.IFDetDLMax" size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.IFDetDLMin" size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">65535</tattr>
        <tattr name="output.IFDetDLSamples" size="SAMPLE_SZ" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.IFDetULMax" size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.IFDetULMin" size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">65535</tattr>
        <tattr name="output.IFDetULSamples" size="SAMPLE_SZ" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.RxDetMax" size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.RxDetMin" size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">65535</tattr>
        <tattr name="output.RxDetSamples" size="SAMPLE_SZ" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.TxDetMax" size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.TxDetMin" size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">65535</tattr>
        <tattr name="output.TxDetSamples" size="SAMPLE_SZ" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.adcValue" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.channelsIdx" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.cruLock" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.pAccValueBuffer" desc="32-bit accumulator value for each ADC channel (L[0], H[0], ..., L[n], H[n]), to be accessed as a uint32_t array in the System CPU application" size="ACC_VALUE_BUFFER_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.alertEnabled" desc="Is ALERT interrupt generation enabled?" type="dec" content="struct" scope="task" min="0" max="65535">1</tattr>
        <tattr name="state.altrenateDetIdx" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.channelHold" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.channelsIdx" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.channelsSwitch" desc="Channel select - 0: measure all channels, 1 - 4: measure only this channel (copied from cfg in Event A)" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.headSamplesCountIFDLDet" desc="ADC sample buffer (input) head index" size="CHANNEL_COUNT" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.headSamplesCountIFULDet" size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.headSamplesCountRxDet" size="CHANNEL_COUNT" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.headSamplesCountTxDet" size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.invalid" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.ledCounter" desc="Determines which LED will turn on in Auto mode" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.ledOn" desc="bool variable to decide weather we light led or ont" type="expr" content="struct" scope="task" min="0" max="1">1</tattr>
        <tattr name="state.pAccValueBuffer" desc="32-bit accumulator value for each ADC channel (L[0], H[0], ..., L[n], H[n]), for storage while accumulating sample values" size="ACC_VALUE_BUFFER_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.samplesCount" type="expr" content="struct" scope="task" min="0" max="65535">2</tattr>
        <tattr name="state.tddMode" desc="TDD mode - 0: Auto, 1: ManualDL, 2: ManualUL  (copied from cfg in Event A)" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <resource_ref name="ADC" enabled="1"/>
        <resource_ref name="AON Domain Functionality" enabled="0"/>
        <resource_ref name="Accumulator-Based Math" enabled="1"/>
        <resource_ref name="Analog Open-Drain Pins" enabled="0"/>
        <resource_ref name="Analog Open-Source Pins" enabled="0"/>
        <resource_ref name="Analog Pins" enabled="1">
            <io_usage name="SENSOR_OUTPUT" label="Analog sensor output">
                <uattr name="Pin count">3</uattr>
                <uattr name="Pin/0000">DIO24</uattr>
                <uattr name="Pin/0001">DIO23</uattr>
                <uattr name="Pin/0002">DIO25</uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
            </io_usage>
        </resource_ref>
        <resource_ref name="COMPA" enabled="0"/>
        <resource_ref name="COMPA Event Trigger" enabled="0"/>
        <resource_ref name="COMPB" enabled="0"/>
        <resource_ref name="COMPB Event Trigger" enabled="0"/>
        <resource_ref name="Delay Insertion" enabled="1"/>
        <resource_ref name="Differential Output Pins" enabled="0"/>
        <resource_ref name="Digital Input Pins" enabled="1">
            <io_usage name="TDD_LOCK" label="TDD lock pin">
                <uattr name="Configuration on initialization">-1</uattr>
                <uattr name="Configuration on uninitialization">-1</uattr>
                <uattr name="Pin count">0</uattr>
                <uattr name="Pin/0000">DIO15</uattr>
                <uattr name="Pin/0001"></uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
                <uattr name="Pin/0008"></uattr>
                <uattr name="Pin/0009"></uattr>
                <uattr name="Pin/0010"></uattr>
                <uattr name="Pin/0011"></uattr>
                <uattr name="Pin/0012"></uattr>
                <uattr name="Pin/0013"></uattr>
                <uattr name="Pin/0014"></uattr>
                <uattr name="Pin/0015"></uattr>
                <uattr name="Pin/0016"></uattr>
                <uattr name="Pin/0017"></uattr>
                <uattr name="Pin/0018"></uattr>
                <uattr name="Pin/0019"></uattr>
                <uattr name="Pin/0020"></uattr>
                <uattr name="Pin/0021"></uattr>
                <uattr name="Pin/0022"></uattr>
                <uattr name="Pin/0023"></uattr>
                <uattr name="Pin/0024"></uattr>
                <uattr name="Pin/0025"></uattr>
                <uattr name="Pin/0026"></uattr>
                <uattr name="Pin/0027"></uattr>
                <uattr name="Pin/0028"></uattr>
                <uattr name="Pin/0029"></uattr>
                <uattr name="Pin/0030"></uattr>
                <uattr name="Pin/0031"></uattr>
            </io_usage>
            <io_usage name="TDD_SYNCH" label="TDD synchronization pin">
                <uattr name="Configuration on initialization">0</uattr>
                <uattr name="Configuration on uninitialization">-1</uattr>
                <uattr name="Pin count">0</uattr>
                <uattr name="Pin/0000">DIO14</uattr>
                <uattr name="Pin/0001"></uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
                <uattr name="Pin/0008"></uattr>
                <uattr name="Pin/0009"></uattr>
                <uattr name="Pin/0010"></uattr>
                <uattr name="Pin/0011"></uattr>
                <uattr name="Pin/0012"></uattr>
                <uattr name="Pin/0013"></uattr>
                <uattr name="Pin/0014"></uattr>
                <uattr name="Pin/0015"></uattr>
                <uattr name="Pin/0016"></uattr>
                <uattr name="Pin/0017"></uattr>
                <uattr name="Pin/0018"></uattr>
                <uattr name="Pin/0019"></uattr>
                <uattr name="Pin/0020"></uattr>
                <uattr name="Pin/0021"></uattr>
                <uattr name="Pin/0022"></uattr>
                <uattr name="Pin/0023"></uattr>
                <uattr name="Pin/0024"></uattr>
                <uattr name="Pin/0025"></uattr>
                <uattr name="Pin/0026"></uattr>
                <uattr name="Pin/0027"></uattr>
                <uattr name="Pin/0028"></uattr>
                <uattr name="Pin/0029"></uattr>
                <uattr name="Pin/0030"></uattr>
                <uattr name="Pin/0031"></uattr>
            </io_usage>
        </resource_ref>
        <resource_ref name="Digital Open-Drain Pins" enabled="0"/>
        <resource_ref name="Digital Open-Source Pins" enabled="0"/>
        <resource_ref name="Digital Output Pins" enabled="1">
            <io_usage name="CHANNEL_CONTROL" label="Channel control PINS">
                <uattr name="Configuration on uninitialization">-1</uattr>
                <uattr name="Output drive strength">0</uattr>
                <uattr name="Output value on initialization">0</uattr>
                <uattr name="Pin count">2</uattr>
                <uattr name="Pin/0000">DIO26</uattr>
                <uattr name="Pin/0001">DIO27</uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
                <uattr name="Pin/0008"></uattr>
                <uattr name="Pin/0009"></uattr>
                <uattr name="Pin/0010"></uattr>
                <uattr name="Pin/0011"></uattr>
                <uattr name="Pin/0012"></uattr>
                <uattr name="Pin/0013"></uattr>
                <uattr name="Pin/0014"></uattr>
                <uattr name="Pin/0015"></uattr>
                <uattr name="Pin/0016"></uattr>
                <uattr name="Pin/0017"></uattr>
                <uattr name="Pin/0018"></uattr>
                <uattr name="Pin/0019"></uattr>
                <uattr name="Pin/0020"></uattr>
                <uattr name="Pin/0021"></uattr>
                <uattr name="Pin/0022"></uattr>
                <uattr name="Pin/0023"></uattr>
                <uattr name="Pin/0024"></uattr>
                <uattr name="Pin/0025"></uattr>
                <uattr name="Pin/0026"></uattr>
                <uattr name="Pin/0027"></uattr>
                <uattr name="Pin/0028"></uattr>
                <uattr name="Pin/0029"></uattr>
                <uattr name="Pin/0030"></uattr>
                <uattr name="Pin/0031"></uattr>
            </io_usage>
            <io_usage name="RED_LED" label="Controls the red LED">
                <uattr name="Configuration on uninitialization">-1</uattr>
                <uattr name="Output drive strength">0</uattr>
                <uattr name="Output value on initialization">0</uattr>
                <uattr name="Pin count">0</uattr>
                <uattr name="Pin/0000">DIO6</uattr>
                <uattr name="Pin/0001"></uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
                <uattr name="Pin/0008"></uattr>
                <uattr name="Pin/0009"></uattr>
                <uattr name="Pin/0010"></uattr>
                <uattr name="Pin/0011"></uattr>
                <uattr name="Pin/0012"></uattr>
                <uattr name="Pin/0013"></uattr>
                <uattr name="Pin/0014"></uattr>
                <uattr name="Pin/0015"></uattr>
                <uattr name="Pin/0016"></uattr>
                <uattr name="Pin/0017"></uattr>
                <uattr name="Pin/0018"></uattr>
                <uattr name="Pin/0019"></uattr>
                <uattr name="Pin/0020"></uattr>
                <uattr name="Pin/0021"></uattr>
                <uattr name="Pin/0022"></uattr>
                <uattr name="Pin/0023"></uattr>
                <uattr name="Pin/0024"></uattr>
                <uattr name="Pin/0025"></uattr>
                <uattr name="Pin/0026"></uattr>
                <uattr name="Pin/0027"></uattr>
                <uattr name="Pin/0028"></uattr>
                <uattr name="Pin/0029"></uattr>
                <uattr name="Pin/0030"></uattr>
                <uattr name="Pin/0031"></uattr>
            </io_usage>
            <io_usage name="GREEN_LED" label="Controls the green LED">
                <uattr name="Configuration on uninitialization">-1</uattr>
                <uattr name="Output drive strength">0</uattr>
                <uattr name="Output value on initialization">0</uattr>
                <uattr name="Pin count">0</uattr>
                <uattr name="Pin/0000">DIO7</uattr>
                <uattr name="Pin/0001"></uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
                <uattr name="Pin/0008"></uattr>
                <uattr name="Pin/0009"></uattr>
                <uattr name="Pin/0010"></uattr>
                <uattr name="Pin/0011"></uattr>
                <uattr name="Pin/0012"></uattr>
                <uattr name="Pin/0013"></uattr>
                <uattr name="Pin/0014"></uattr>
                <uattr name="Pin/0015"></uattr>
                <uattr name="Pin/0016"></uattr>
                <uattr name="Pin/0017"></uattr>
                <uattr name="Pin/0018"></uattr>
                <uattr name="Pin/0019"></uattr>
                <uattr name="Pin/0020"></uattr>
                <uattr name="Pin/0021"></uattr>
                <uattr name="Pin/0022"></uattr>
                <uattr name="Pin/0023"></uattr>
                <uattr name="Pin/0024"></uattr>
                <uattr name="Pin/0025"></uattr>
                <uattr name="Pin/0026"></uattr>
                <uattr name="Pin/0027"></uattr>
                <uattr name="Pin/0028"></uattr>
                <uattr name="Pin/0029"></uattr>
                <uattr name="Pin/0030"></uattr>
                <uattr name="Pin/0031"></uattr>
            </io_usage>
        </resource_ref>
        <resource_ref name="Dynamic Power Control" enabled="0"/>
        <resource_ref name="GPIO Event Trigger" enabled="1"/>
        <resource_ref name="I2C Master" enabled="0">
            <rattr name="SCL frequency">0</rattr>
            <rattr name="SCL stretch timeout">1</rattr>
            <io_usage>
                <uattr name="Output drive strength">1</uattr>
                <uattr name="SCL pin/0000"></uattr>
                <uattr name="SDA pin/0000"></uattr>
            </io_usage>
        </resource_ref>
        <resource_ref name="ISRC" enabled="0"/>
        <resource_ref name="LCD Controller" enabled="0">
            <rattr name="Waveform state count">8</rattr>
            <io_usage>
                <uattr name="Output drive strength">0</uattr>
                <uattr name="Pin count">20</uattr>
                <uattr name="Pin/0000"></uattr>
                <uattr name="Pin/0001"></uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
                <uattr name="Pin/0008"></uattr>
                <uattr name="Pin/0009"></uattr>
                <uattr name="Pin/0010"></uattr>
                <uattr name="Pin/0011"></uattr>
                <uattr name="Pin/0012"></uattr>
                <uattr name="Pin/0013"></uattr>
                <uattr name="Pin/0014"></uattr>
                <uattr name="Pin/0015"></uattr>
                <uattr name="Pin/0016"></uattr>
                <uattr name="Pin/0017"></uattr>
                <uattr name="Pin/0018"></uattr>
                <uattr name="Pin/0019"></uattr>
                <uattr name="Pin/0020"></uattr>
                <uattr name="Pin/0021"></uattr>
                <uattr name="Pin/0022"></uattr>
                <uattr name="Pin/0023"></uattr>
                <uattr name="Pin/0024"></uattr>
                <uattr name="Pin/0025"></uattr>
                <uattr name="Pin/0026"></uattr>
                <uattr name="Pin/0027"></uattr>
                <uattr name="Pin/0028"></uattr>
                <uattr name="Pin/0029"></uattr>
                <uattr name="Pin/0030"></uattr>
                <uattr name="Pin/0031"></uattr>
            </io_usage>
        </resource_ref>
        <resource_ref name="Math and Logic" enabled="1"/>
        <resource_ref name="Multi-Buffered Output Data Exchange" enabled="0">
            <rattr name="Buffer count">2</rattr>
            <rattr name="Indicate overflow at buffer check">0</rattr>
            <rattr name="Indicate overflow at buffer switch">0</rattr>
            <rattr name="Prevent overflow at buffer switch">0</rattr>
        </resource_ref>
        <resource_ref name="Peripheral Sharing" enabled="0"/>
        <resource_ref name="Pulse Counter" enabled="0"/>
        <resource_ref name="RTC Multi-Event Capture" enabled="0"/>
        <resource_ref name="RTC-Based Execution Scheduling" enabled="0"/>
        <resource_ref name="Reference DAC" enabled="0"/>
        <resource_ref name="Run-Time Logging" enabled="1"/>
        <resource_ref name="SPI Chip Select" enabled="0"/>
        <resource_ref name="SPI Data Transfer" enabled="0">
            <rattr name="Bit rate">0</rattr>
            <rattr name="MISO configuration when inactive">-1</rattr>
            <rattr name="MOSI configuration on initialization">0</rattr>
            <rattr name="MOSI configuration on uninitialization">0</rattr>
            <rattr name="SCLK configuration on initialization">0</rattr>
            <rattr name="SCLK configuration on uninitialization">0</rattr>
            <io_usage>
                <uattr name="MISO pin/0000"></uattr>
                <uattr name="MOSI pin/0000"></uattr>
                <uattr name="SCLK pin/0000"></uattr>
            </io_usage>
        </resource_ref>
        <resource_ref name="Signal Observation" enabled="0"/>
        <resource_ref name="System CPU Alert" enabled="1"/>
        <resource_ref name="System Event Trigger" enabled="0"/>
        <resource_ref name="TDC" enabled="0"/>
        <resource_ref name="Timer 0" enabled="0"/>
        <resource_ref name="Timer 0 Event Trigger" enabled="1"/>
        <resource_ref name="Timer 1" enabled="1"/>
        <resource_ref name="Timer 1 Event Trigger" enabled="0"/>
        <resource_ref name="Timer 2" enabled="0"/>
        <resource_ref name="Timer 2 Event Trigger" enabled="0"/>
        <resource_ref name="UART Emulator" enabled="0">
            <rattr name="RX buffer size">64</rattr>
            <rattr name="Required idle period before enabling RX">11</rattr>
            <rattr name="TX buffer size">64</rattr>
            <io_usage>
                <uattr name="RX pin/0000"></uattr>
                <uattr name="TX pin/0000"></uattr>
            </io_usage>
        </resource_ref>
        <sccode name="event0" init_power_mode="0"><![CDATA[//evhCancelTrigger(#evIndex)
//Cancels a previous call to an event trigger setup procedure (for example evhSetupGpioTrigger() ) with matching event index, including any pending Event Handler Code execution if the trigger already has occurred. This procedure should be called from the Termination Code if the task can be stopped by the application while an event trigger is enabled.
evhCancelTrigger(1); //cancel event B trigger

if(cfg.channelsSwitch!=0){
if(cfg.Dio26==1){
    gpioSetOutput(cfg.pAuxioOChannelControl[0]);//aux 23-->DIO 26
}else{
    gpioClearOutput(cfg.pAuxioOChannelControl[0]);//aux 23-->DIO 26
}

if(cfg.Dio27==1){
    gpioSetOutput(cfg.pAuxioOChannelControl[1]);//aux 22-->DIO 27

}else{
    gpioClearOutput(cfg.pAuxioOChannelControl[1]);//aux 23-->DIO 26
}
}



U16 z=0;

z = state.channelHold;
utilIncrAndWrap(z, CHANNEL_HOLD_NUM; state.channelHold);

if(z==0){
z = state.channelsIdx;
utilIncrAndWrap(z, TP_CHANNEL_COUNT; state.channelsIdx);
}





//// update state's TDD mode, channels select and unit Type from the cfg (only on the start of a new sampling cycle)
//if(state.test == (SAMPLE_SZ-1)){
//    state.tddMode = cfg.tddMode;
//    state.channelsSwitch = cfg.channelsSwitch;
//    state.unitType = cfg.unitType;
//}

//// check if the TDD mode was changed in the middle of the sampling cycles
if(state.tddMode == cfg.tddMode){
    state.invalid = 0;
}
//else{
//    // if it was, mark currently stored result as invalid, advance the sample counter to the last cycle
//    // and trigger the next event so results will get discarded
//    state.invalid = 1;
//    state.samplesCount = 1;
//    evhSetupTimer0Trigger(1, 1, 2);
//    fwWaitForEvSignal(FW_WAIT_SIGNAL_TIMER0_EV, 1);
//}


// if tdd mode is auto
if(state.tddMode == 0){

    //**Led logic**//
    if(state.ledCounter == 0){
        gpioSetOutput(AUXIO_O_RED_LED);
        gpioSetOutput(AUXIO_O_GREEN_LED);
        //turn off cruLock
        output.cruLock=0;
    }
    if(state.ledCounter >= 100){
        gpioSetOutput(AUXIO_O_RED_LED);
        gpioSetOutput(AUXIO_O_GREEN_LED);
        //turn off cruLock
        output.cruLock=0;
        state.ledCounter = 0;
    }

    if(state.ledOn==0){
        gpioClearOutput(AUXIO_O_RED_LED);
        gpioClearOutput(AUXIO_O_GREEN_LED);
    }
    //**Led logic**//

    state.ledCounter += 1;
    //get the TDD lock
    U16 lock;
    // in CDU we get it directly from the PIN
    gpioGetInputValue(AUXIO_I_TDD_LOCK; lock);
    // lock detect PIN: 0-locked, 1-not locked (XOR to flip it)
    lock ^= 1;
    //if locked, activate the rising edge interrupt on event B
    if(lock == 1){
        //evhSetupGpioTrigger(#evIndex, #auxio, #level, #type)
        //Sets up a GPIO pin to generate an Event Handler Code trigger. Event indexes are mapped to event handlers in the task panel. The trigger is one-shot.
        //The trigger occurs as soon as the GPIO pin matches or transitions to the selected level. The Event Handler Code block that matches the specified event index then starts when the Sensor Controller is idle or in standby mode.
        //Parameter value(s)
        //#evIndex : Event index to be triggered
        //#auxio : The GPIO pin that shall generate the trigger (index of AUX I/O pin)
        //#level : The pin level that shall generate the trigger (1 = high level / rising edge, 0 = low level / falling edge)
        //#type : GPIO trigger type (EVH_GPIO_TRIG_ON_MATCH to trigger immediately on match, or EVH_GPIO_TRIG_ON_EDGE to wait for a transition to the leve
        evhSetupGpioTrigger(1, AUXIO_I_TDD_SYNCH, 1, EVH_GPIO_TRIG_ON_EDGE); //trigeer event B on Rising edge of TDD Sync pin(Tx/Rx control)
    }
    //Activate timer trigger on event A, so if interrupt does not occur or there is no lock then event runs again from the start . timer of 100 ms
    evhSetupTimer0Trigger(0, 100, 2);

}else{
    // if mode is not auto, trigger event B immediately
    evhSetupTimer0Trigger(1, 1, 2);
}]]></sccode>
        <sccode name="event1" init_power_mode="0"><![CDATA[//rising edge - CDU: Tx det(Rf DL)/IF det (DL)
//              CRU: Rx det(Rf DL)/IF det (DL)
//evhCancelTrigger(0);//cancel event A trigger
//enter event code only if Manual DL mode(1) or Auto(0)(skip if Manual UL)
if(state.tddMode != 2){
    //**Led logic**//
    // turn DL LED on (in auto mode it stays on only half the time)
    if(state.tddMode == 0){
        if(state.ledCounter < 50){
            gpioClearOutput(AUXIO_O_RED_LED);
            gpioSetOutput(AUXIO_O_GREEN_LED);
            //set cruLock
            output.cruLock=1;
        }
    }else{ // state.tddMode != 0
        gpioClearOutput(AUXIO_O_RED_LED);
        gpioSetOutput(AUXIO_O_GREEN_LED);//sets BLUE static
    }
    if(state.ledOn==0){
        gpioClearOutput(AUXIO_O_RED_LED);
        gpioClearOutput(AUXIO_O_GREEN_LED);
    }
    //**Led logic**//
    U16 z;
    //    z=state.altrenateDetIdx;
    //    utilIncrAndWrap(z, 2; state.altrenateDetIdx);
    //    if(state.altrenateDetIdx==0){

    //channel switch config
    z = state.channelsIdx;
    utilIncrAndWrap(z, TP_CHANNEL_COUNT; state.channelsIdx);
    if(cfg.channelsSwitch==0){
        if(state.channelsIdx==0){
            gpioSetOutput(cfg.pAuxioOChannelControl[0]);//aux 23-->DIO 26
            gpioSetOutput(cfg.pAuxioOChannelControl[1]);//aux 22-->DIO 27
        }
        if(state.channelsIdx==1){
            gpioClearOutput(cfg.pAuxioOChannelControl[0]);//aux 23-->DIO 26
            gpioSetOutput(cfg.pAuxioOChannelControl[1]);//aux 22-->DIO 27
        }
        if(state.channelsIdx==2){
            gpioSetOutput(cfg.pAuxioOChannelControl[0]);//aux 23-->DIO 26
            gpioClearOutput(cfg.pAuxioOChannelControl[1]);//aux 22-->DIO 27
        }
        if(state.channelsIdx==3){
            gpioClearOutput(cfg.pAuxioOChannelControl[0]);//aux 23-->DIO 26
            gpioClearOutput(cfg.pAuxioOChannelControl[1]);//aux 22-->DIO 27
        }
        output.channelsIdx=state.channelsIdx;
    }else{
        output.channelsIdx=cfg.channelsSwitch;
        state.channelsIdx=cfg.channelsSwitch;
    }
    // Calculate the memory offset between the accumulator value buffer in the output and state data structures.
    // We'll use this to quickly move the pointer back and forth (saves 3 instructions per move).
    //pAccValueBuffer[0]-pAccValueBuffer[1]: Tx channel 0
    //pAccValueBuffer[2]-pAccValueBuffer[3]: Tx channel 1
    //pAccValueBuffer[4]-pAccValueBuffer[5]: Tx channel 2
    //pAccValueBuffer[6]-pAccValueBuffer[7]: Tx channel 3

    //pAccValueBuffer[8]-pAccValueBuffer[9]:   Rx channel 0
    //pAccValueBuffer[10]-pAccValueBuffer[11]: Rx channel 1
    //pAccValueBuffer[12]-pAccValueBuffer[13]: Rx channel 2
    //pAccValueBuffer[14]-pAccValueBuffer[15]: Rx channel 3

    //pAccValueBuffer[16]-pAccValueBuffer[17]: IF Det DL channel 0
    //pAccValueBuffer[18]-pAccValueBuffer[19]: IF Det DL channel 1
    //pAccValueBuffer[20]-pAccValueBuffer[21]: IF Det DL channel 2
    //pAccValueBuffer[22]-pAccValueBuffer[23]: IF Det DL channel 3

    //pAccValueBuffer[24]-pAccValueBuffer[25]: IF Det UL channel 0
    //pAccValueBuffer[26]-pAccValueBuffer[27]: IF Det UL channel 1
    //pAccValueBuffer[28]-pAccValueBuffer[29]: IF Det UL channel 2
    //pAccValueBuffer[30]-pAccValueBuffer[31]: IF Det UL channel 3
    //To create a pointer to a data structure member, use the # operator.
    U16 accValueBufferOutputOffset = #output.pAccValueBuffer - #state.pAccValueBuffer;
    U16* pAccValueBuffer = #state.pAccValueBuffer[0]; //To create a pointer to a data structure member, use the # operator.
    if(state.channelsIdx == 0){
        pAccValueBuffer = #state.pAccValueBuffer[8];
    }
    if(state.channelsIdx == 1){
        pAccValueBuffer = #state.pAccValueBuffer[10];
    }
    if(state.channelsIdx == 2){
        pAccValueBuffer = #state.pAccValueBuffer[12];
    }
    if(state.channelsIdx == 3){
        pAccValueBuffer = #state.pAccValueBuffer[14];
    }
    U16 n = 0;
    U16 accExt=0;
    U16 accValueL=0;
    U16 accValueH=0;
    // Reset the accumulator for the first sample in a block, or restore the accumulator for the current channel
    U16 flagAccReset=0;
    if(state.channelsIdx==0){
        if (state.headSamplesCountRxDet[0] == 0) {
            accReset();
            flagAccReset=1;
        }
    }

    if(state.channelsIdx==1){
        if (state.headSamplesCountRxDet[1] == 0) {
            accReset();
            flagAccReset=1;
        }
    }
    if(state.channelsIdx==2){
        if (state.headSamplesCountRxDet[2] == 0) {
            accReset();
            flagAccReset=1;
        }
    }
    if(state.channelsIdx==3){
        if (state.headSamplesCountRxDet[3] == 0) {
            accReset();
            flagAccReset=1;
        }
    }

    if(flagAccReset==0) {
        U16 accValueL = *(pAccValueBuffer++);
        U16 accValueH = *(pAccValueBuffer++);
        accSet32u(accValueH, accValueL);
        pAccValueBuffer -= 2;
    }
    flagAccReset=0;
    //fwDelayUs(#delay, #range)
    //Delays execution of the next line by the specified number of microseconds.
    //To avoid busy waiting, the delay is implemented using AUX Timer 0.
    //Parameter value(s)
    //#delay : Delay value in microseconds
    //#range : Delay range (FW_DELAY_RANGE_N_US or FW_DELAY_RANGE_N_MS), for example FW_DELAY_RANGE_5_MS allows for a delay between 1 and 5000 microseconds
    fwDelayUs(input.gapStartTx);
    // select the correct pin according to unit type. For CDU we select
    // Rx detect PIN(Tal's card), for CRU we select Tx detect PIN(FEM card)
    //Selects a GPIO pin as input for the ADC. Note that calling this procedure also selects the same input for COMPB. adcSelectGpioInput(auxio) -->(auxio : External input selection (index of AUX I/O pin))
    adcSelectGpioInput(cfg.pAuxioASensorOutput[0]); //AUX Mapping 25--->DIO 24 RX det


    //adcEnableSync(#refSource, #sampleTime, #trigger)
    //Enables the ADC for synchronous operation, with a fixed sampling period before each conversion.
    //The ADC is idle between conversions, and the ADC trigger starts the sampling period before the conversion.
    //This procedure must only be called when the ADC is disabled. To change ADC configuration, call adcDisable() before re-enabling the ADC.
    //Parameter value(s)
    //#refSource : ADC reference source, either ADC_REF_FIXED or ADC_REF_VDDS_REL
    //#sampleTime : ADC sampling time before each conversion, ADC_SAMPLE_TIME_N_US or ADC_SAMPLE_TIME_N_MS
    //#trigger : ADC trigger (ADC_TRIGGER_XYZ)
    //adcEnableSync(ADC_REF_FIXED, ADC_SAMPLE_TIME_2P7_US, ADC_TRIGGER_MANUAL); // manual sampling, 2.7 us sample time, the fastest possible
    adcEnableSync(ADC_REF_FIXED, ADC_SAMPLE_TIME_2P7_US, ADC_TRIGGER_AUX_TIMER1); // period sampling, 2.7 us sample time, the fastest possible
    adcFlushFifo();
    // Start ADC timer trigger at the configured period (rounded up)
    timer1Start(TIMER1_MODE_PERIODICAL, (24000000 + (ADC_SAMPLE_RATE - 1)) / ADC_SAMPLE_RATE, 0);
    // Wait for the ADC trigger (start of conversion)
    timer1Wait();

    if(state.channelsIdx==0){
        n = state.headSamplesCountRxDet[0];
    }
    if(state.channelsIdx==1){
        n = state.headSamplesCountRxDet[1];
    }
    if(state.channelsIdx==2){
        n = state.headSamplesCountRxDet[2];
    }
    if(state.channelsIdx==3){
        n = state.headSamplesCountRxDet[3];
    }
    adcReadFifo(output.RxDetSamples[n]); //ADC FIFO can store between between 0 and 4 samples.
    output.adcValue=output.RxDetSamples[n];


    // Add the ADC value to the accumulator
    accAdd16u(output.adcValue);
    accGetAll(accExt, accValueH, accValueL);
    // Before the accumulator contains the wanted number of samples: Save the accumulator value to
    // state.pAccValueBuffer[], so it can be restored in the next iteration
    U16 flagLastCycle=0;
    if(state.channelsIdx==0){
        if (state.headSamplesCountRxDet[0] != (SAMPLE_SZ - 1)) {
            flagLastCycle=1;
        }
    }
    if(state.channelsIdx==1){
        if (state.headSamplesCountRxDet[1] != (SAMPLE_SZ - 1)) {
            flagLastCycle=1;
        }
    }

    if(state.channelsIdx==2){
        if (state.headSamplesCountRxDet[2] != (SAMPLE_SZ - 1)) {
            flagLastCycle=1;
        }
    }

    if(state.channelsIdx==3){
        if (state.headSamplesCountRxDet[3] != (SAMPLE_SZ - 1)) {
            flagLastCycle=1;
        }
    }

    if(flagLastCycle==1){
        *(pAccValueBuffer++) = accValueL;
        *(pAccValueBuffer++) = accValueH;
    }
    // When the accumulator contains the wanted number of samples: Save the accumulator value to
    // output.pAccValueBuffer[] instead, so it can be handed over to the System CPU application
    if(flagLastCycle==0) {
        pAccValueBuffer += accValueBufferOutputOffset;//moves the ptr to output structure
        *(pAccValueBuffer++) = accValueL;
        *(pAccValueBuffer++) = accValueH;
        pAccValueBuffer -= accValueBufferOutputOffset; //move the ptr back to state structure
    }
    // Update the head index
    if(state.channelsIdx==0){
        utilIncrAndWrap(n, SAMPLE_SZ; state.headSamplesCountRxDet[0]);
    }
    if(state.channelsIdx==1){
        utilIncrAndWrap(n, SAMPLE_SZ; state.headSamplesCountRxDet[1]);
    }
    if(state.channelsIdx==2){
        utilIncrAndWrap(n, SAMPLE_SZ; state.headSamplesCountRxDet[2]);
    }
    if(state.channelsIdx==3){
        utilIncrAndWrap(n, SAMPLE_SZ; state.headSamplesCountRxDet[3]);
    }


    n=state.channelsIdx;
    //min, max, sum calculations
    if(output.adcValue<output.RxDetMin[n]){
        output.RxDetMin[n]=output.adcValue;
    }
    if(output.adcValue>output.RxDetMax[n]){
        output.RxDetMax[n]=output.adcValue;
    }

    adcDisable();
    //    }//end of if(state.altrenateDetIdx==0)

    //    if(state.altrenateDetIdx==1){
    //move to sample IF det DL
    //pAccValueBuffer[0]-pAccValueBuffer[1]: Tx channel 0
    //pAccValueBuffer[2]-pAccValueBuffer[3]: Tx channel 1
    //pAccValueBuffer[4]-pAccValueBuffer[5]: Tx channel 2
    //pAccValueBuffer[6]-pAccValueBuffer[7]: Tx channel 3

    //pAccValueBuffer[8]-pAccValueBuffer[9]:   Rx channel 0
    //pAccValueBuffer[10]-pAccValueBuffer[11]: Rx channel 1
    //pAccValueBuffer[12]-pAccValueBuffer[13]: Rx channel 2
    //pAccValueBuffer[14]-pAccValueBuffer[15]: Rx channel 3

    //pAccValueBuffer[16]-pAccValueBuffer[17]: IF Det DL channel 0
    //pAccValueBuffer[18]-pAccValueBuffer[19]: IF Det DL channel 1
    //pAccValueBuffer[20]-pAccValueBuffer[21]: IF Det DL channel 2
    //pAccValueBuffer[22]-pAccValueBuffer[23]: IF Det DL channel 3

    //pAccValueBuffer[24]-pAccValueBuffer[25]: IF Det UL channel 0
    //pAccValueBuffer[26]-pAccValueBuffer[27]: IF Det UL channel 1
    //pAccValueBuffer[28]-pAccValueBuffer[29]: IF Det UL channel 2
    //pAccValueBuffer[30]-pAccValueBuffer[31]: IF Det UL channel 3
    //        U16 accValueBufferOutputOffset = #output.pAccValueBuffer - #state.pAccValueBuffer;
    //        U16* pAccValueBuffer = #state.pAccValueBuffer[0]; //To create a pointer to a data structure member, use the # operator.
    if(state.channelsIdx == 0){
        pAccValueBuffer = #state.pAccValueBuffer[16];
    }
    if(state.channelsIdx == 1){
        pAccValueBuffer = #state.pAccValueBuffer[18];
    }
    if(state.channelsIdx == 2){
        pAccValueBuffer = #state.pAccValueBuffer[20];
    }
    if(state.channelsIdx == 3){
        pAccValueBuffer = #state.pAccValueBuffer[22];
    }
    // Reset the accumulator for the first sample in a block, or restore the accumulator for the current channel
    flagAccReset=0;
    if(state.channelsIdx==0){
        if (state.headSamplesCountIFDLDet[0] == 0) {
            accReset();
            flagAccReset=1;
        }
    }

    if(state.channelsIdx==1){
        if (state.headSamplesCountIFDLDet[1] == 0) {
            accReset();
            flagAccReset=1;
        }
    }
    if(state.channelsIdx==2){
        if (state.headSamplesCountIFDLDet[2] == 0) {
            accReset();
            flagAccReset=1;
        }
    }
    if(state.channelsIdx==3){
        if (state.headSamplesCountIFDLDet[3] == 0) {
            accReset();
            flagAccReset=1;
        }
    }
    U16 accExt_2=0;
    U16  accValueL_2 =0;
    U16  accValueH_2 =0;
    if(flagAccReset==0) {
        accValueL_2 = *(pAccValueBuffer++);
        accValueH_2 = *(pAccValueBuffer++);
        accSet32u(accValueH_2 ,accValueL_2);
        pAccValueBuffer -= 2;
    }
    flagAccReset=0;


    // select the IF pin
    adcSelectGpioInput(cfg.pAuxioASensorOutput[2]); //AUX Mapping 24--->DIO 25 IF det
    adcEnableSync(ADC_REF_FIXED, ADC_SAMPLE_TIME_2P7_US, ADC_TRIGGER_AUX_TIMER1); // period sampling, 2.7 us sample time, the fastest possible
    adcFlushFifo();
    // Wait for the ADC trigger (start of conversion)
    timer1Wait();
    adcFlushFifo();
    fwDelayUs(input.gapStartRx);
    n=0;
    if(state.channelsIdx==0){
        n = state.headSamplesCountIFDLDet[0];
    }
    if(state.channelsIdx==1){
        n = state.headSamplesCountIFDLDet[1];
    }
    if(state.channelsIdx==2){
        n = state.headSamplesCountIFDLDet[2];
    }
    if(state.channelsIdx==3){
        n = state.headSamplesCountIFDLDet[3];
    }
    adcReadFifo(output.IFDetDLSamples[n]); //ADC FIFO can store between between 0 and 4 samples.
    output.adcValue=output.IFDetDLSamples[n];
    // Add the ADC value to the accumulator
    accAdd16u(output.adcValue);
    accGetAll(accExt_2, accValueH_2, accValueL_2);
    // Before the accumulator contains the wanted number of samples: Save the accumulator value to
    // state.pAccValueBuffer[], so it can be restored in the next iteration
    flagLastCycle=0;
    if(state.channelsIdx==0){
        if (state.headSamplesCountIFDLDet[0] != (SAMPLE_SZ - 1)) {
            flagLastCycle=1;
        }
    }
    if(state.channelsIdx==1){
        if (state.headSamplesCountIFDLDet[1] != (SAMPLE_SZ - 1)) {
            flagLastCycle=1;
        }
    }

    if(state.channelsIdx==2){
        if (state.headSamplesCountIFDLDet[2] != (SAMPLE_SZ - 1)) {
            flagLastCycle=1;
        }
    }

    if(state.channelsIdx==3){
        if (state.headSamplesCountIFDLDet[3] != (SAMPLE_SZ - 1)) {
            flagLastCycle=1;
        }
    }

    if(flagLastCycle==1){
        *(pAccValueBuffer++) = accValueL_2;
        *(pAccValueBuffer++) = accValueH_2;
    }
    // When the accumulator contains the wanted number of samples: Save the accumulator value to
    // output.pAccValueBuffer[] instead, so it can be handed over to the System CPU application
    if(flagLastCycle==0) {
        pAccValueBuffer += accValueBufferOutputOffset;//moves the ptr to output structure
        *(pAccValueBuffer++) = accValueL_2;
        *(pAccValueBuffer++) = accValueH_2;
        pAccValueBuffer -= accValueBufferOutputOffset; //move the ptr back to state structure
    }

    // Update the head index
    if(state.channelsIdx==0){
        utilIncrAndWrap(n, SAMPLE_SZ; state.headSamplesCountIFDLDet[0]);
    }
    if(state.channelsIdx==1){
        utilIncrAndWrap(n, SAMPLE_SZ; state.headSamplesCountIFDLDet[1]);
    }
    if(state.channelsIdx==2){
        utilIncrAndWrap(n, SAMPLE_SZ; state.headSamplesCountIFDLDet[2]);
    }
    if(state.channelsIdx==3){
        utilIncrAndWrap(n, SAMPLE_SZ; state.headSamplesCountIFDLDet[3]);
    }

    n=state.channelsIdx;
    //min, max, sum calculations
    if(output.adcValue<output.IFDetDLMin[n]){
        output.IFDetDLMin[n]=output.adcValue;
    }
    if(output.adcValue>output.IFDetDLMax[n]){
        output.IFDetDLMax[n]=output.adcValue;
    }

    // Stop the ADC trigger and flush the ADC FIFO
    timer1Stop();
    fwDelayUs(3);// wait for any ongoing conversion (taking ~2.3 us) to finish
    adcFlushFifo();
    adcDisable();    //Disable the ADC driver after use
    //}//end of if(state.altrenateDetIdx==1)


    if(state.invalid != 1){
        // if TDD mode is manual DL, results are ready and an interrupt is sent to main CPU
        if(state.tddMode == 1){
            state.samplesCount = SAMPLE_SIZE;
            // if interrupt flag is enabled, raises the interrupt for application to process results
            if(state.alertEnabled == 1) {
                state.alertEnabled = 0;
                // Disable further generation to avoid unnecessary interrupts. It will be reenabled
                // by the application after handling the ALERT interrupt.
                fwGenQuickAlertInterrupt();

            }
        }
    } else{
        state.samplesCount = SAMPLE_SIZE;
        evhSetupTimer0Trigger(2, 1, 2);
        fwWaitForEvSignal(FW_WAIT_SIGNAL_TIMER0_EV, 1);
    }

    // if TDD mode is auto, trigger the next falling edge interrupt for UL Event C
    if(state.tddMode == 0){
        evhSetupGpioTrigger(2, AUXIO_I_TDD_SYNCH, 0, EVH_GPIO_TRIG_ON_EDGE);
        evhSetupTimer0Trigger(0, 100, 2);
    }else{
        // if not, immediately trigger event C
        evhSetupTimer0Trigger(2, 1, 2);
    }

}else{//else of if tddMode!=2
    // if mode is not Manual DL/ Auto, immediately trigger event C
    evhSetupTimer0Trigger(2, 1, 2);
}]]></sccode>
        <sccode name="event2" init_power_mode="0"><![CDATA[//faling edge - CDU: Rx det(Rf UL)/IF det (UL)
//              CRU: Tx det(Rf UL)/IF det (UL)
//evhCancelTrigger(0);//cancel event A trigger


//enter event code only if Manual UL mode(2) or Auto(0)(skip if Manual DL)
if(state.tddMode != 1){
    //**Led logic**//
    // turn UL LED on (in auto mode it stays on only half the time)
    if(state.tddMode == 0){
        if(state.ledCounter > 50){
            gpioClearOutput(AUXIO_O_GREEN_LED);
            gpioSetOutput(AUXIO_O_RED_LED);
            //set cruLock
            output.cruLock=1;
        }
    }else{
        gpioClearOutput(AUXIO_O_GREEN_LED);
        gpioSetOutput(AUXIO_O_RED_LED);
    }
    if(state.ledOn==0){
        gpioClearOutput(AUXIO_O_RED_LED);
        gpioClearOutput(AUXIO_O_GREEN_LED);
    }
    //**Led logic**//


    U16 z;
    //    z=state.altrenateDetIdx;
    //    utilIncrAndWrap(z, 2; state.altrenateDetIdx);
    //    if(state.altrenateDetIdx==0){


    //channel switch config
    z = state.channelsIdx;
    utilIncrAndWrap(z, TP_CHANNEL_COUNT; state.channelsIdx);
    if(cfg.channelsSwitch==0){

        if(state.channelsIdx==3){
            gpioSetOutput(cfg.pAuxioOChannelControl[0]);//aux 23-->DIO 26
            gpioSetOutput(cfg.pAuxioOChannelControl[1]);//aux 22-->DIO 27
        }
        if(state.channelsIdx==2){
            gpioClearOutput(cfg.pAuxioOChannelControl[0]);//aux 23-->DIO 26
            gpioSetOutput(cfg.pAuxioOChannelControl[1]);//aux 22-->DIO 27
        }
        if(state.channelsIdx==1){
            gpioSetOutput(cfg.pAuxioOChannelControl[0]);//aux 23-->DIO 26
            gpioClearOutput(cfg.pAuxioOChannelControl[1]);//aux 22-->DIO 27
        }
        if(state.channelsIdx==0){
            gpioClearOutput(cfg.pAuxioOChannelControl[0]);//aux 23-->DIO 26
            gpioClearOutput(cfg.pAuxioOChannelControl[1]);//aux 22-->DIO 27
        }
        output.channelsIdx=state.channelsIdx;
    }else{
        output.channelsIdx=cfg.channelsSwitch;
        state.channelsIdx=cfg.channelsSwitch;
    }




    // Calculate the memory offset between the accumulator value buffer in the output and state data structures.
    // We'll use this to quickly move the pointer back and forth (saves 3 instructions per move).
    //pAccValueBuffer[0]-pAccValueBuffer[1]: Tx channel 0
    //pAccValueBuffer[2]-pAccValueBuffer[3]: Tx channel 1
    //pAccValueBuffer[4]-pAccValueBuffer[5]: Tx channel 2
    //pAccValueBuffer[6]-pAccValueBuffer[7]: Tx channel 3

    //pAccValueBuffer[8]-pAccValueBuffer[9]:   Rx channel 0
    //pAccValueBuffer[10]-pAccValueBuffer[11]: Rx channel 1
    //pAccValueBuffer[12]-pAccValueBuffer[13]: Rx channel 2
    //pAccValueBuffer[14]-pAccValueBuffer[15]: Rx channel 3

    //pAccValueBuffer[16]-pAccValueBuffer[17]: IF Det DL channel 0
    //pAccValueBuffer[18]-pAccValueBuffer[19]: IF Det DL channel 1
    //pAccValueBuffer[20]-pAccValueBuffer[21]: IF Det DL channel 2
    //pAccValueBuffer[22]-pAccValueBuffer[23]: IF Det DL channel 3

    //pAccValueBuffer[24]-pAccValueBuffer[25]: IF Det UL channel 0
    //pAccValueBuffer[26]-pAccValueBuffer[27]: IF Det UL channel 1
    //pAccValueBuffer[28]-pAccValueBuffer[29]: IF Det UL channel 2
    //pAccValueBuffer[30]-pAccValueBuffer[31]: IF Det UL channel 3
    //To create a pointer to a data structure member, use the # operator.
    U16 accValueBufferOutputOffset = #output.pAccValueBuffer - #state.pAccValueBuffer;
    U16* pAccValueBuffer = #state.pAccValueBuffer[0]; //To create a pointer to a data structure member, use the # operator.
    if(state.channelsIdx == 0){
        pAccValueBuffer = #state.pAccValueBuffer[0];
    }
    if(state.channelsIdx == 1){
        pAccValueBuffer = #state.pAccValueBuffer[2];
    }
    if(state.channelsIdx == 2){
        pAccValueBuffer = #state.pAccValueBuffer[4];
    }
    if(state.channelsIdx == 3){
        pAccValueBuffer = #state.pAccValueBuffer[6];
    }
    U16 n = 0;
    U16 accExt;
    U16 accValueL;
    U16 accValueH;
    // Reset the accumulator for the first sample in a block, or restore the accumulator for the current channel
    U16 flagAccReset=0;
    if(state.channelsIdx==0){
        if (state.headSamplesCountTxDet[0] == 0) {
            accReset();
            flagAccReset=1;
        }
    }

    if(state.channelsIdx==1){
        if (state.headSamplesCountTxDet[1] == 0) {
            accReset();
            flagAccReset=1;
        }
    }
    if(state.channelsIdx==2){
        if (state.headSamplesCountTxDet[2] == 0) {
            accReset();
            flagAccReset=1;
        }
    }
    if(state.channelsIdx==3){
        if (state.headSamplesCountTxDet[3] == 0) {
            accReset();
            flagAccReset=1;
        }
    }

    if(flagAccReset==0) {
        U16 accValueL = *(pAccValueBuffer++);
        U16 accValueH = *(pAccValueBuffer++);
        accSet32u(accValueH, accValueL);
        pAccValueBuffer -= 2;
    }
    flagAccReset=0;

    // select the correct pin according to unit type. For CDU we select
    // Rx detect PIN(Tal's card), for CRU we select Tx detect PIN(FEM card)
    //Selects a GPIO pin as input for the ADC. Note that calling this procedure also selects the same input for COMPB. adcSelectGpioInput(auxio) -->(auxio : External input selection (index of AUX I/O pin))
    adcSelectGpioInput(cfg.pAuxioASensorOutput[1]); //AUX Mapping 26--->DIO 23 TX det

    //U16 adcValue;
    fwDelayUs(input.gapStartRx);
    //adcEnableSync(ADC_REF_FIXED, ADC_SAMPLE_TIME_2P7_US, ADC_TRIGGER_MANUAL); // period sampling, 2.7 us sample time, the fastest possible
    adcEnableSync(ADC_REF_FIXED, ADC_SAMPLE_TIME_2P7_US, ADC_TRIGGER_AUX_TIMER1); // period sampling, 2.7 us sample time, the fastest possible
    adcFlushFifo();
    // Start ADC timer trigger at the configured period (rounded up)
    timer1Start(TIMER1_MODE_PERIODICAL, (24000000 + (ADC_SAMPLE_RATE - 1)) / ADC_SAMPLE_RATE, 0);


    if(state.channelsIdx==0){
        n = state.headSamplesCountTxDet[0];
    }
    if(state.channelsIdx==1){
        n = state.headSamplesCountTxDet[1];
    }
    if(state.channelsIdx==2){
        n = state.headSamplesCountTxDet[2];
    }
    if(state.channelsIdx==3){
        n = state.headSamplesCountTxDet[3];
    }

    adcReadFifo(output.TxDetSamples[n]);
    output.adcValue=output.TxDetSamples[n];
    // Add the ADC value to the accumulator
    accAdd16u(output.adcValue);
    accGetAll(accExt, accValueH, accValueL);
    // Before the accumulator contains the wanted number of samples: Save the accumulator value to
    // state.pAccValueBuffer[], so it can be restored in the next iteration
    U16 flagLastCycle=0;
    if(state.channelsIdx==0){
        if (state.headSamplesCountTxDet[0] != (SAMPLE_SZ - 1)) {
            flagLastCycle=1;
        }
    }
    if(state.channelsIdx==1){
        if (state.headSamplesCountTxDet[1] != (SAMPLE_SZ - 1)) {
            flagLastCycle=1;
        }
    }

    if(state.channelsIdx==2){
        if (state.headSamplesCountTxDet[2] != (SAMPLE_SZ - 1)) {
            flagLastCycle=1;
        }
    }

    if(state.channelsIdx==3){
        if (state.headSamplesCountTxDet[3] != (SAMPLE_SZ - 1)) {
            flagLastCycle=1;
        }
    }

    if(flagLastCycle==1){
        *(pAccValueBuffer++) = accValueL;
        *(pAccValueBuffer++) = accValueH;
    }
    // When the accumulator contains the wanted number of samples: Save the accumulator value to
    // output.pAccValueBuffer[] instead, so it can be handed over to the System CPU application
    if(flagLastCycle==0) {
        pAccValueBuffer += accValueBufferOutputOffset;//moves the ptr to output structure
        *(pAccValueBuffer++) = accValueL;
        *(pAccValueBuffer++) = accValueH;
        pAccValueBuffer -= accValueBufferOutputOffset; //move the ptr back to state structure
    }
    // Update the head index
    if(state.channelsIdx==0){
        utilIncrAndWrap(n, SAMPLE_SZ; state.headSamplesCountTxDet[0]);
    }
    if(state.channelsIdx==1){
        utilIncrAndWrap(n, SAMPLE_SZ; state.headSamplesCountTxDet[1]);
    }
    if(state.channelsIdx==2){
        utilIncrAndWrap(n, SAMPLE_SZ; state.headSamplesCountTxDet[2]);
    }
    if(state.channelsIdx==3){
        utilIncrAndWrap(n, SAMPLE_SZ; state.headSamplesCountTxDet[3]);
    }

    n=state.channelsIdx;
    //min, max, sum calculations
    if(output.adcValue<output.TxDetMin[n]){
        output.TxDetMin[n]=output.adcValue;
    }
    if(output.adcValue>output.TxDetMax[n]){
        output.TxDetMax[n]=output.adcValue;
    }




    adcDisable();

    //    }//end of if(state.altrenateDetIdx==0)

    //    if(state.altrenateDetIdx==1){
    //move to sample IF det UL
    if(cfg.channelsSwitch==0){
        if(state.channelsIdx==0){
            gpioSetOutput(cfg.pAuxioOChannelControl[0]);//aux 23-->DIO 26
            gpioSetOutput(cfg.pAuxioOChannelControl[1]);//aux 22-->DIO 27
        }
        if(state.channelsIdx==1){
            gpioClearOutput(cfg.pAuxioOChannelControl[0]);//aux 23-->DIO 26
            gpioSetOutput(cfg.pAuxioOChannelControl[1]);//aux 22-->DIO 27
        }
        if(state.channelsIdx==2){
            gpioSetOutput(cfg.pAuxioOChannelControl[0]);//aux 23-->DIO 26
            gpioClearOutput(cfg.pAuxioOChannelControl[1]);//aux 22-->DIO 27
        }
        if(state.channelsIdx==3){
            gpioClearOutput(cfg.pAuxioOChannelControl[0]);//aux 23-->DIO 26
            gpioClearOutput(cfg.pAuxioOChannelControl[1]);//aux 22-->DIO 27
        }
        output.channelsIdx=state.channelsIdx;
    }else{
        output.channelsIdx=cfg.channelsSwitch;
    }

    //pAccValueBuffer[0]-pAccValueBuffer[1]: Tx channel 0
    //pAccValueBuffer[2]-pAccValueBuffer[3]: Tx channel 1
    //pAccValueBuffer[4]-pAccValueBuffer[5]: Tx channel 2
    //pAccValueBuffer[6]-pAccValueBuffer[7]: Tx channel 3

    //pAccValueBuffer[8]-pAccValueBuffer[9]:   Rx channel 0
    //pAccValueBuffer[10]-pAccValueBuffer[11]: Rx channel 1
    //pAccValueBuffer[12]-pAccValueBuffer[13]: Rx channel 2
    //pAccValueBuffer[14]-pAccValueBuffer[15]: Rx channel 3

    //pAccValueBuffer[16]-pAccValueBuffer[17]: IF Det DL channel 0
    //pAccValueBuffer[18]-pAccValueBuffer[19]: IF Det DL channel 1
    //pAccValueBuffer[20]-pAccValueBuffer[21]: IF Det DL channel 2
    //pAccValueBuffer[22]-pAccValueBuffer[23]: IF Det DL channel 3

    //pAccValueBuffer[24]-pAccValueBuffer[25]: IF Det UL channel 0
    //pAccValueBuffer[26]-pAccValueBuffer[27]: IF Det UL channel 1
    //pAccValueBuffer[28]-pAccValueBuffer[29]: IF Det UL channel 2
    //pAccValueBuffer[30]-pAccValueBuffer[31]: IF Det UL channel 3
    //        U16 accValueBufferOutputOffset = #output.pAccValueBuffer - #state.pAccValueBuffer;
    //        U16* pAccValueBuffer = #state.pAccValueBuffer[0]; //To create a pointer to a data structure member, use the # operator.
    if(state.channelsIdx == 0){
        pAccValueBuffer = #state.pAccValueBuffer[24];
    }
    if(state.channelsIdx == 1){
        pAccValueBuffer = #state.pAccValueBuffer[26];
    }
    if(state.channelsIdx == 2){
        pAccValueBuffer = #state.pAccValueBuffer[28];
    }
    if(state.channelsIdx == 3){
        pAccValueBuffer = #state.pAccValueBuffer[30];
    }
    //        U16 accExt;
    //        U16 accValueL;
    //        U16 accValueH;
    // Reset the accumulator for the first sample in a block, or restore the accumulator for the current channel
    flagAccReset=0;
    if(state.channelsIdx==0){
        if (state.headSamplesCountIFULDet[0] == 0) {
            accReset();
            flagAccReset=1;
        }
    }

    if(state.channelsIdx==1){
        if (state.headSamplesCountIFULDet[1] == 0) {
            accReset();
            flagAccReset=1;
        }
    }
    if(state.channelsIdx==2){
        if (state.headSamplesCountIFULDet[2] == 0) {
            accReset();
            flagAccReset=1;
        }
    }
    if(state.channelsIdx==3){
        if (state.headSamplesCountIFULDet[3] == 0) {
            accReset();
            flagAccReset=1;
        }
    }

    if(flagAccReset==0) {
        U16 accValueL = *(pAccValueBuffer++);
        U16 accValueH = *(pAccValueBuffer++);
        accSet32u(accValueH, accValueL);
        pAccValueBuffer -= 2;
    }
    flagAccReset=0;

    // select the IF pin
    adcSelectGpioInput(cfg.pAuxioASensorOutput[2]); //AUX Mapping 24--->DIO 25 IF det
    adcEnableSync(ADC_REF_FIXED, ADC_SAMPLE_TIME_2P7_US, ADC_TRIGGER_AUX_TIMER1); // period sampling, 2.7 us sample time, the fastest possible
    adcFlushFifo();
    // Wait for the ADC trigger (start of conversion)
    timer1Wait();
    adcFlushFifo();
    fwDelayUs(input.gapStartRx);
    n=0;
    if(state.channelsIdx==0){
        n = state.headSamplesCountIFULDet[0];
    }
    if(state.channelsIdx==1){
        n = state.headSamplesCountIFULDet[1];
    }
    if(state.channelsIdx==2){
        n = state.headSamplesCountIFULDet[2];
    }
    if(state.channelsIdx==3){
        n = state.headSamplesCountIFULDet[3];
    }
    adcReadFifo(output.IFDetULSamples[n]);
    output.adcValue=output.IFDetULSamples[n];

    // Add the ADC value to the accumulator
    accAdd16u(output.adcValue);
    accGetAll(accExt, accValueH, accValueL);
    // Before the accumulator contains the wanted number of samples: Save the accumulator value to
    // state.pAccValueBuffer[], so it can be restored in the next iteration
    flagLastCycle=0;
    if(state.channelsIdx==0){
        if (state.headSamplesCountIFULDet[0] != (SAMPLE_SZ - 1)) {
            flagLastCycle=1;
        }
    }
    if(state.channelsIdx==1){
        if (state.headSamplesCountIFULDet[1] != (SAMPLE_SZ - 1)) {
            flagLastCycle=1;
        }
    }

    if(state.channelsIdx==2){
        if (state.headSamplesCountIFULDet[2] != (SAMPLE_SZ - 1)) {
            flagLastCycle=1;
        }
    }

    if(state.channelsIdx==3){
        if (state.headSamplesCountIFULDet[3] != (SAMPLE_SZ - 1)) {
            flagLastCycle=1;
        }
    }

    if(flagLastCycle==1){
        *(pAccValueBuffer++) = accValueL;
        *(pAccValueBuffer++) = accValueH;
    }
    // When the accumulator contains the wanted number of samples: Save the accumulator value to
    // output.pAccValueBuffer[] instead, so it can be handed over to the System CPU application
    if(flagLastCycle==0) {
        pAccValueBuffer += accValueBufferOutputOffset;//moves the ptr to output structure
        *(pAccValueBuffer++) = accValueL;
        *(pAccValueBuffer++) = accValueH;
        pAccValueBuffer -= accValueBufferOutputOffset; //move the ptr back to state structure
    }

    // Update the head index
    if(state.channelsIdx==0){
        utilIncrAndWrap(n, SAMPLE_SZ; state.headSamplesCountIFULDet[0]);
    }
    if(state.channelsIdx==1){
        utilIncrAndWrap(n, SAMPLE_SZ; state.headSamplesCountIFULDet[1]);
    }
    if(state.channelsIdx==2){
        utilIncrAndWrap(n, SAMPLE_SZ; state.headSamplesCountIFULDet[2]);
    }
    if(state.channelsIdx==3){
        utilIncrAndWrap(n, SAMPLE_SZ; state.headSamplesCountIFULDet[3]);
    }

    n=state.channelsIdx;
    //min, max, sum calculations
    if(output.adcValue<output.IFDetULMin[n]){
        output.IFDetULMin[n]=output.adcValue;
    }
    if(output.adcValue>output.IFDetULMax[n]){
        output.IFDetULMax[n]=output.adcValue;
    }








    // Stop the ADC trigger and flush the ADC FIFO
    timer1Stop();
    fwDelayUs(3);// wait for any ongoing conversion (taking ~2.3 us) to finish
    adcFlushFifo();
    adcDisable();    //Disable the ADC driver after use
    //    }//end of if state.altrenateDetIdx == 1


    if(state.invalid != 1){
        // if TDD mode is manual UL or Auto, results are ready and an interrupt is sent to main CPU
        state.samplesCount = SAMPLE_SIZE;
        rtlLogStructs(BV_RTL_LOG_OUTPUT);
        // if interrupt flag is enabled, raises the interrupt for application to process results
        if(state.alertEnabled == 1) {
            state.alertEnabled = 0;
            fwGenQuickAlertInterrupt();

        }
    } else{
        state.samplesCount = SAMPLE_SIZE;
        evhSetupTimer0Trigger(0, 1, 2);
        fwWaitForEvSignal(FW_WAIT_SIGNAL_TIMER0_EV, 1);
    }


}// end of if state.tddMode != 1
// trigger event A
evhSetupTimer0Trigger(0, 1, 2);]]></sccode>
        <sccode name="event3" init_power_mode="0"><![CDATA[]]></sccode>
        <sccode name="execute" init_power_mode="0"><![CDATA[]]></sccode>
        <sccode name="initialize" init_power_mode="0"><![CDATA[//read docs here - https://software-dl.ti.com/lprf/sensor_controller_studio/docs/cc13x0_cc26x0_help/html/scs_overview.html


//evhSetupTimer0Trigger(#evIndex, mant, #exp)
//Sets up AUX Timer 0 to trigger execution of the Event Handler Code after a specified delay.
//The timer runs off 4 kHz ticks (4096 Hz) generated by the RTC. Note the following limitations:
//The timeout is rounded up to the closest number of 4 kHz ticks
//The 4 kHz tick rate is matched to the RTC rate, which may be adjusted dynamically if running off RCOSC LF
//The trigger occurs after the delay. The specified Event Handler Code then starts when the Sensor Controller is idle or in standby.
evhSetupTimer0Trigger(0, 1, 0); // start event A right away


//TX det DIO 23 (CDU) (AUX MAPING: 26)
//RX det DIO 24 (CDU) (AUX MAPING: 25)
//IF det DIO 25 (AUX MAPING: 24)

//CDU: TDD SYNC PIN rising-Rx,IF DL
//     TDD SYNC PIN falling-Tx,IF UL
//CRU: TDD SYNC PIN rising-Tx,IF
//     TDD SYNC PIN falling-Rx,IF]]></sccode>
        <sccode name="terminate" init_power_mode="0"><![CDATA[// cancel events trigger on termination
// Cancel the Timer 0 trigger generated by the Initialization Code, in case the task was stopped immediately
evhCancelTrigger(0);
evhCancelTrigger(1);
evhCancelTrigger(2);]]></sccode>
        <event_trigger active_count="3">0,1,2,3</event_trigger>
        <tt_iter>run_event0,run_event1,run_event2</tt_iter>
        <tt_struct>state.channelsIdx</tt_struct>
        <rtl_struct>cfg.tddMode</rtl_struct>
        <rtl_task_sel en="1" struct_log_list="output,cfg"/>
    </task>
</project>
