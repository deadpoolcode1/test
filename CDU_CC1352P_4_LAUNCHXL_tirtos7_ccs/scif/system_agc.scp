<?xml version="1.0" encoding="UTF-8"?>
<project name="System AGC" version="2.9.0.208">
    <desc><![CDATA[Samples 4 channels for TX/RX voltage, calculates min and max values of these measures for each channel and raises AlertInterrupt for main application when done.
Sampling occurs only when TDD is locked and connected to the configured GPIO pins.]]></desc>
    <pattr name="Apply default power mode">0</pattr>
    <pattr name="Board">CC1352P* LaunchPad</pattr>
    <pattr name="Chip name">CC1352P1F3</pattr>
    <pattr name="Chip package">QFN48 7x7 RGZ</pattr>
    <pattr name="Chip revision">E</pattr>
    <pattr name="Clock in active mode">0</pattr>
    <pattr name="Code prefix"></pattr>
    <pattr name="Default power mode">0</pattr>
    <pattr name="Operating system">TI-RTOS</pattr>
    <pattr name="Output directory">C:\Users\cellium\workspace_v12\crs_tirtos_test\CDU_CC1352P_4_LAUNCHXL_tirtos7_ccs\scif</pattr>
    <pattr name="RTC tick interval (16.16 format)">2000</pattr>
    <pattr name="Run-time logging UART RX pin"></pattr>
    <pattr name="Run-time logging UART TX pin"></pattr>
    <task name="System AGC">
        <desc><![CDATA[Samples 4 channels for TX/RX voltage, calculates min and max values of these measures for each channel and raises AlertInterrupt for main application when done.
Sampling occurs only when TDD is locked and connected to the configured GPIO pins.]]></desc>
        <tattr name="AVERAGE_SIZE" desc="The size of the array of the sums of the samples results (for each channel sum of samples from DLRF, ULRF, DLIF, ULIF)." type="expr" content="const" scope="task" min="0" max="65535">CHANNELS_NUMBER*4</tattr>
        <tattr name="BUFFER_SIZE" desc="Number of measures on each channel from one sample cycle (one DL/UL period)" type="expr" content="const" scope="task" min="0" max="65535">10</tattr>
        <tattr name="CHANNELS_NUMBER" desc="Number of channels" type="expr" content="const" scope="task" min="0" max="65535">4</tattr>
        <tattr name="MIN_MAX_CHANNELS_SIZE" desc="15% of results from all samples across cycles for a given channel" type="expr" content="const" scope="task" min="0" max="65535">(MODES_SIZE - (MODES_SIZE/4))/CHANNELS_NUMBER</tattr>
        <tattr name="MODES_CHANNEL_SIZE" desc="20% of results from all samples across cycles for a given channel" type="expr" content="const" scope="task" min="0" max="65535">MODES_SIZE / CHANNELS_NUMBER</tattr>
        <tattr name="MODES_SIZE" desc="20% of sample across all cycles and channels" type="expr" content="const" scope="task" min="0" max="65535">(MULTI_RESULT_SIZE / 10) * 2</tattr>
        <tattr name="MULTI_BUFFER_SIZE" desc="Number of samples from all channels in each sample cycle" type="expr" content="const" scope="task" min="0" max="65535">BUFFER_SIZE * CHANNELS_NUMBER</tattr>
        <tattr name="MULTI_RESULT_SIZE" desc="Total number of measures from all channels across all samples cycles" type="expr" content="const" scope="task" min="0" max="65535">SAMPLE_SIZE*MULTI_BUFFER_SIZE</tattr>
        <tattr name="RESULTS" desc="Number of measures for a channel across all sample cycles" type="expr" content="const" scope="task" min="0" max="65535">BUFFER_SIZE*SAMPLE_SIZE</tattr>
        <tattr name="SAMPLE_SIZE" desc="Number of sample cycles" type="expr" content="const" scope="task" min="0" max="65535">2</tattr>
        <tattr name="cfg.channelsSwitch" desc="Channel select - 0: measure all channels, 1 - 4: measure only this channel" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="cfg.eventCounter" desc="counts transitons number from event b(UL) to c(DL)" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="cfg.tddMode" desc="TDD mode - 0: ManualDL, 1: ManualUL, 2: Auto" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="cfg.unitType" desc="Type of unit - 0 : CDU, 1: CRU" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="input.randomDelayDL" desc="Random delay period after interrupt wakeup and before starting to perform measures(DL event). Contains multiple numbers for each sample cylce." size="SAMPLE_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="input.randomDelayUL" desc="Random delay period after interrupt wakeup and before starting to perform measures(UL event). Contains multiple numbers for each sample cylce." size="SAMPLE_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="input.tddLock" desc="TDD lock status" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.channelsAverage" desc="Contains sums of 90% of results of measures for each channel and type of measure: [sumsChannel1-4DLRF, sumsChannel1-4ULRF, sumsChannel1-4DLIF,  sumsChannel1-4ULIF]." size="AVERAGE_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.channelsAverageTemp" desc="Stores the average sums between calculations, is not accessed by the CPU and copied into the non-temp array after calculation is done." size="AVERAGE_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.channelsMaxIFDL" desc="Contains sums of the 15% max results from downlink IF of channels 1-4." size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.channelsMaxIFDLTemp" desc="Stores the max sums between calculations, is not accessed by the CPU and copied into the non-temp array after calculation is done." size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.channelsMaxIFUL" desc="Contains sums of the 15% max results from uplink IF of channels 1-4." size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.channelsMaxIFULTemp" desc="Stores the max sums between calculations, is not accessed by the CPU and copied into the non-temp array after calculation is done." size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.channelsMaxRFDL" desc="Contains sums of the 15% max results from downlink RF of channels 1-4." size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.channelsMaxRFDLTemp" desc="Stores the max sums between calculations, is not accessed by the CPU and copied into the non-temp array after calculation is done." size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.channelsMaxRFUL" desc="Contains sums of the 15% max results from uplink RF of channels 1-4." size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.channelsMaxRFULTemp" desc="Stores the max sums between calculations, is not accessed by the CPU and copied into the non-temp array after calculation is done." size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.channelsMinIFDL" desc="Contains sums of the 15% min results from downlink IF of channels 1-4." size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.channelsMinIFDLTemp" desc="Stores the min sums between calculations, is not accessed by the CPU and copied into the non-temp array after calculation is done." size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.channelsMinIFUL" desc="Contains sums of the 15% min results from uplink IF of channels 1-4." size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.channelsMinIFULTemp" desc="Stores the min sums between calculations, is not accessed by the CPU and copied into the non-temp array after calculation is done." size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.channelsMinRFDL" desc="Contains sums of the 15% min results from downlink RF of channels 1-4." size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.channelsMinRFDLTemp" desc="Stores the min sums between calculations, is not accessed by the CPU and copied into the non-temp array after calculation is done." size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.channelsMinRFUL" desc="Contains sums of the 15% min results from uplink RF of channels 1-4." size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.channelsMinRFULTemp" desc="Stores the min sums between calculations, is not accessed by the CPU and copied into the non-temp array after calculation is done." size="CHANNELS_NUMBER" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.maxSamplesIFDL" desc="Contains the 20% top reasults for each channel from all smaple cycles for IF downlink: [channel1MaxSamples,  channel2MaxSamples, channel3MaxSamples, channel4MaxSamples]." size="MODES_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.maxSamplesIFUL" desc="Contains the 20% top reasults for each channel from all smaple cycles for IF uplink: [channel1MaxSamples,  channel2MaxSamples, channel3MaxSamples, channel4MaxSamples]." size="MODES_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.maxSamplesRFDL" desc="Contains the 20% top reasults for each channel from all smaple cycles for RF downlink: [channel1MaxSamples,  channel2MaxSamples, channel3MaxSamples, channel4MaxSamples]." size="MODES_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.maxSamplesRFUL" desc="Contains the 20% top reasults for each channel from all smaple cycles for RF uplink: [channel1MaxSamples,  channel2MaxSamples, channel3MaxSamples, channel4MaxSamples]." size="MODES_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.minSamplesIFDL" desc="Contains the 20% bottom reasults for each channel from all smaple cycles for IF downlink [channel1MinSamples,  channel2MinSamples, channel3MinSamples, channel4MinSamples]." size="MODES_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">65535</tattr>
        <tattr name="output.minSamplesIFUL" desc="Contains the 20% bottom reasults for each channel from all smaple cycles for IF uplink [channel1MinSamples,  channel2MinSamples, channel3MinSamples, channel4MinSamples]." size="MODES_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">65535</tattr>
        <tattr name="output.minSamplesRFDL" desc="Contains the 20% bottom reasults for each channel from all smaple cycles for RF downlink [channel1MinSamples,  channel2MinSamples, channel3MinSamples, channel4MinSamples]." size="MODES_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">65535</tattr>
        <tattr name="output.minSamplesRFUL" desc="Contains the 20% bottom reasults for each channel from all smaple cycles for RF uplink [channel1MinSamples,  channel2MinSamples, channel3MinSamples, channel4MinSamples]." size="MODES_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">65535</tattr>
        <tattr name="output.pSamplesMultiChannelIF" desc="Stores IF samples of each sample cycle from each channel" size="MULTI_BUFFER_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.pSamplesMultiChannelRF" desc="Stores RF samples of each sample cycle from each channel" size="MULTI_BUFFER_SIZE" type="expr" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.alertEnabled" desc="Is ALERT interrupt generation enabled?" type="dec" content="struct" scope="task" min="0" max="65535">1</tattr>
        <tattr name="state.channelsSwitch" desc="Channel select - 0: measure all channels, 1 - 4: measure only this channel (copied from cfg in Event A)" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.exit" desc="Set to exit the ADC data streamer" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.invalid" desc="signal that results of current sample cycle should be discarded and not copied to the results arrays." type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.ledCounter" desc="Determines which LED will turn on in Auto mode" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.ledOn" desc="bool variable to decide weather we light led or ont" type="expr" content="struct" scope="task" min="0" max="1">1</tattr>
        <tattr name="state.samplesCount" desc="The sample cycles counter" type="expr" content="struct" scope="task" min="0" max="65535">SAMPLE_SIZE</tattr>
        <tattr name="state.tddMode" desc="TDD mode - 0: Auto, 1: ManualDL, 2: ManualUL  (copied from cfg in Event A)" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.unitType" desc="Type of unit - 0 : CDU, 1: CRU  (copied from cfg in Event A)" type="expr" content="struct" scope="task" min="0" max="65535">0</tattr>
        <resource_ref name="ADC" enabled="1"/>
        <resource_ref name="AON Domain Functionality" enabled="0"/>
        <resource_ref name="Accumulator-Based Math" enabled="1"/>
        <resource_ref name="Analog Open-Drain Pins" enabled="0"/>
        <resource_ref name="Analog Open-Source Pins" enabled="0"/>
        <resource_ref name="Analog Pins" enabled="1">
            <io_usage name="SENSOR_OUTPUT" label="Analog sensor output">
                <uattr name="Pin count">3</uattr>
                <uattr name="Pin/0000">DIO24</uattr>
                <uattr name="Pin/0001">DIO23</uattr>
                <uattr name="Pin/0002">DIO25</uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
            </io_usage>
        </resource_ref>
        <resource_ref name="COMPA" enabled="0"/>
        <resource_ref name="COMPA Event Trigger" enabled="0"/>
        <resource_ref name="COMPB" enabled="0"/>
        <resource_ref name="COMPB Event Trigger" enabled="0"/>
        <resource_ref name="Delay Insertion" enabled="1"/>
        <resource_ref name="Differential Output Pins" enabled="0"/>
        <resource_ref name="Digital Input Pins" enabled="1">
            <io_usage name="TDD_LOCK" label="TDD lock pin">
                <uattr name="Configuration on initialization">-1</uattr>
                <uattr name="Configuration on uninitialization">-1</uattr>
                <uattr name="Pin count">0</uattr>
                <uattr name="Pin/0000">DIO15</uattr>
                <uattr name="Pin/0001"></uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
                <uattr name="Pin/0008"></uattr>
                <uattr name="Pin/0009"></uattr>
                <uattr name="Pin/0010"></uattr>
                <uattr name="Pin/0011"></uattr>
                <uattr name="Pin/0012"></uattr>
                <uattr name="Pin/0013"></uattr>
                <uattr name="Pin/0014"></uattr>
                <uattr name="Pin/0015"></uattr>
                <uattr name="Pin/0016"></uattr>
                <uattr name="Pin/0017"></uattr>
                <uattr name="Pin/0018"></uattr>
                <uattr name="Pin/0019"></uattr>
                <uattr name="Pin/0020"></uattr>
                <uattr name="Pin/0021"></uattr>
                <uattr name="Pin/0022"></uattr>
                <uattr name="Pin/0023"></uattr>
                <uattr name="Pin/0024"></uattr>
                <uattr name="Pin/0025"></uattr>
                <uattr name="Pin/0026"></uattr>
                <uattr name="Pin/0027"></uattr>
                <uattr name="Pin/0028"></uattr>
                <uattr name="Pin/0029"></uattr>
                <uattr name="Pin/0030"></uattr>
                <uattr name="Pin/0031"></uattr>
            </io_usage>
            <io_usage name="TDD_SYNCH" label="TDD synchronization pin">
                <uattr name="Configuration on initialization">0</uattr>
                <uattr name="Configuration on uninitialization">-1</uattr>
                <uattr name="Pin count">0</uattr>
                <uattr name="Pin/0000">DIO14</uattr>
                <uattr name="Pin/0001"></uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
                <uattr name="Pin/0008"></uattr>
                <uattr name="Pin/0009"></uattr>
                <uattr name="Pin/0010"></uattr>
                <uattr name="Pin/0011"></uattr>
                <uattr name="Pin/0012"></uattr>
                <uattr name="Pin/0013"></uattr>
                <uattr name="Pin/0014"></uattr>
                <uattr name="Pin/0015"></uattr>
                <uattr name="Pin/0016"></uattr>
                <uattr name="Pin/0017"></uattr>
                <uattr name="Pin/0018"></uattr>
                <uattr name="Pin/0019"></uattr>
                <uattr name="Pin/0020"></uattr>
                <uattr name="Pin/0021"></uattr>
                <uattr name="Pin/0022"></uattr>
                <uattr name="Pin/0023"></uattr>
                <uattr name="Pin/0024"></uattr>
                <uattr name="Pin/0025"></uattr>
                <uattr name="Pin/0026"></uattr>
                <uattr name="Pin/0027"></uattr>
                <uattr name="Pin/0028"></uattr>
                <uattr name="Pin/0029"></uattr>
                <uattr name="Pin/0030"></uattr>
                <uattr name="Pin/0031"></uattr>
            </io_usage>
        </resource_ref>
        <resource_ref name="Digital Open-Drain Pins" enabled="0"/>
        <resource_ref name="Digital Open-Source Pins" enabled="0"/>
        <resource_ref name="Digital Output Pins" enabled="1">
            <io_usage name="CHANNEL_CONTROL" label="Channel control PINS">
                <uattr name="Configuration on uninitialization">-1</uattr>
                <uattr name="Output drive strength">0</uattr>
                <uattr name="Output value on initialization">0</uattr>
                <uattr name="Pin count">2</uattr>
                <uattr name="Pin/0000">DIO26</uattr>
                <uattr name="Pin/0001">DIO27</uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
                <uattr name="Pin/0008"></uattr>
                <uattr name="Pin/0009"></uattr>
                <uattr name="Pin/0010"></uattr>
                <uattr name="Pin/0011"></uattr>
                <uattr name="Pin/0012"></uattr>
                <uattr name="Pin/0013"></uattr>
                <uattr name="Pin/0014"></uattr>
                <uattr name="Pin/0015"></uattr>
                <uattr name="Pin/0016"></uattr>
                <uattr name="Pin/0017"></uattr>
                <uattr name="Pin/0018"></uattr>
                <uattr name="Pin/0019"></uattr>
                <uattr name="Pin/0020"></uattr>
                <uattr name="Pin/0021"></uattr>
                <uattr name="Pin/0022"></uattr>
                <uattr name="Pin/0023"></uattr>
                <uattr name="Pin/0024"></uattr>
                <uattr name="Pin/0025"></uattr>
                <uattr name="Pin/0026"></uattr>
                <uattr name="Pin/0027"></uattr>
                <uattr name="Pin/0028"></uattr>
                <uattr name="Pin/0029"></uattr>
                <uattr name="Pin/0030"></uattr>
                <uattr name="Pin/0031"></uattr>
            </io_usage>
            <io_usage name="RED_LED" label="Controls the red LED">
                <uattr name="Configuration on uninitialization">-1</uattr>
                <uattr name="Output drive strength">0</uattr>
                <uattr name="Output value on initialization">0</uattr>
                <uattr name="Pin count">0</uattr>
                <uattr name="Pin/0000">DIO6</uattr>
                <uattr name="Pin/0001"></uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
                <uattr name="Pin/0008"></uattr>
                <uattr name="Pin/0009"></uattr>
                <uattr name="Pin/0010"></uattr>
                <uattr name="Pin/0011"></uattr>
                <uattr name="Pin/0012"></uattr>
                <uattr name="Pin/0013"></uattr>
                <uattr name="Pin/0014"></uattr>
                <uattr name="Pin/0015"></uattr>
                <uattr name="Pin/0016"></uattr>
                <uattr name="Pin/0017"></uattr>
                <uattr name="Pin/0018"></uattr>
                <uattr name="Pin/0019"></uattr>
                <uattr name="Pin/0020"></uattr>
                <uattr name="Pin/0021"></uattr>
                <uattr name="Pin/0022"></uattr>
                <uattr name="Pin/0023"></uattr>
                <uattr name="Pin/0024"></uattr>
                <uattr name="Pin/0025"></uattr>
                <uattr name="Pin/0026"></uattr>
                <uattr name="Pin/0027"></uattr>
                <uattr name="Pin/0028"></uattr>
                <uattr name="Pin/0029"></uattr>
                <uattr name="Pin/0030"></uattr>
                <uattr name="Pin/0031"></uattr>
            </io_usage>
            <io_usage name="GREEN_LED" label="Controls the green LED">
                <uattr name="Configuration on uninitialization">-1</uattr>
                <uattr name="Output drive strength">0</uattr>
                <uattr name="Output value on initialization">0</uattr>
                <uattr name="Pin count">0</uattr>
                <uattr name="Pin/0000">DIO7</uattr>
                <uattr name="Pin/0001"></uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
                <uattr name="Pin/0008"></uattr>
                <uattr name="Pin/0009"></uattr>
                <uattr name="Pin/0010"></uattr>
                <uattr name="Pin/0011"></uattr>
                <uattr name="Pin/0012"></uattr>
                <uattr name="Pin/0013"></uattr>
                <uattr name="Pin/0014"></uattr>
                <uattr name="Pin/0015"></uattr>
                <uattr name="Pin/0016"></uattr>
                <uattr name="Pin/0017"></uattr>
                <uattr name="Pin/0018"></uattr>
                <uattr name="Pin/0019"></uattr>
                <uattr name="Pin/0020"></uattr>
                <uattr name="Pin/0021"></uattr>
                <uattr name="Pin/0022"></uattr>
                <uattr name="Pin/0023"></uattr>
                <uattr name="Pin/0024"></uattr>
                <uattr name="Pin/0025"></uattr>
                <uattr name="Pin/0026"></uattr>
                <uattr name="Pin/0027"></uattr>
                <uattr name="Pin/0028"></uattr>
                <uattr name="Pin/0029"></uattr>
                <uattr name="Pin/0030"></uattr>
                <uattr name="Pin/0031"></uattr>
            </io_usage>
        </resource_ref>
        <resource_ref name="Dynamic Power Control" enabled="0"/>
        <resource_ref name="GPIO Event Trigger" enabled="1"/>
        <resource_ref name="I2C Master" enabled="0">
            <rattr name="SCL frequency">0</rattr>
            <rattr name="SCL stretch timeout">1</rattr>
            <io_usage>
                <uattr name="Output drive strength">1</uattr>
                <uattr name="SCL pin/0000"></uattr>
                <uattr name="SDA pin/0000"></uattr>
            </io_usage>
        </resource_ref>
        <resource_ref name="ISRC" enabled="0"/>
        <resource_ref name="LCD Controller" enabled="0">
            <rattr name="Waveform state count">8</rattr>
            <io_usage>
                <uattr name="Output drive strength">0</uattr>
                <uattr name="Pin count">20</uattr>
                <uattr name="Pin/0000"></uattr>
                <uattr name="Pin/0001"></uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
                <uattr name="Pin/0008"></uattr>
                <uattr name="Pin/0009"></uattr>
                <uattr name="Pin/0010"></uattr>
                <uattr name="Pin/0011"></uattr>
                <uattr name="Pin/0012"></uattr>
                <uattr name="Pin/0013"></uattr>
                <uattr name="Pin/0014"></uattr>
                <uattr name="Pin/0015"></uattr>
                <uattr name="Pin/0016"></uattr>
                <uattr name="Pin/0017"></uattr>
                <uattr name="Pin/0018"></uattr>
                <uattr name="Pin/0019"></uattr>
                <uattr name="Pin/0020"></uattr>
                <uattr name="Pin/0021"></uattr>
                <uattr name="Pin/0022"></uattr>
                <uattr name="Pin/0023"></uattr>
                <uattr name="Pin/0024"></uattr>
                <uattr name="Pin/0025"></uattr>
                <uattr name="Pin/0026"></uattr>
                <uattr name="Pin/0027"></uattr>
                <uattr name="Pin/0028"></uattr>
                <uattr name="Pin/0029"></uattr>
                <uattr name="Pin/0030"></uattr>
                <uattr name="Pin/0031"></uattr>
            </io_usage>
        </resource_ref>
        <resource_ref name="Math and Logic" enabled="1"/>
        <resource_ref name="Multi-Buffered Output Data Exchange" enabled="0">
            <rattr name="Buffer count">2</rattr>
            <rattr name="Indicate overflow at buffer check">0</rattr>
            <rattr name="Indicate overflow at buffer switch">0</rattr>
            <rattr name="Prevent overflow at buffer switch">0</rattr>
        </resource_ref>
        <resource_ref name="Peripheral Sharing" enabled="0"/>
        <resource_ref name="Pulse Counter" enabled="0"/>
        <resource_ref name="RTC Multi-Event Capture" enabled="0"/>
        <resource_ref name="RTC-Based Execution Scheduling" enabled="0"/>
        <resource_ref name="Reference DAC" enabled="0"/>
        <resource_ref name="Run-Time Logging" enabled="1"/>
        <resource_ref name="SPI Chip Select" enabled="0"/>
        <resource_ref name="SPI Data Transfer" enabled="0">
            <rattr name="Bit rate">0</rattr>
            <rattr name="MISO configuration when inactive">-1</rattr>
            <rattr name="MOSI configuration on initialization">0</rattr>
            <rattr name="MOSI configuration on uninitialization">0</rattr>
            <rattr name="SCLK configuration on initialization">0</rattr>
            <rattr name="SCLK configuration on uninitialization">0</rattr>
            <io_usage>
                <uattr name="MISO pin/0000"></uattr>
                <uattr name="MOSI pin/0000"></uattr>
                <uattr name="SCLK pin/0000"></uattr>
            </io_usage>
        </resource_ref>
        <resource_ref name="Signal Observation" enabled="0"/>
        <resource_ref name="System CPU Alert" enabled="1"/>
        <resource_ref name="System Event Trigger" enabled="0"/>
        <resource_ref name="TDC" enabled="0"/>
        <resource_ref name="Timer 0" enabled="0"/>
        <resource_ref name="Timer 0 Event Trigger" enabled="1"/>
        <resource_ref name="Timer 1" enabled="1"/>
        <resource_ref name="Timer 1 Event Trigger" enabled="0"/>
        <resource_ref name="Timer 2" enabled="0"/>
        <resource_ref name="Timer 2 Event Trigger" enabled="0"/>
        <resource_ref name="UART Emulator" enabled="0">
            <rattr name="RX buffer size">64</rattr>
            <rattr name="Required idle period before enabling RX">11</rattr>
            <rattr name="TX buffer size">64</rattr>
            <io_usage>
                <uattr name="RX pin/0000"></uattr>
                <uattr name="TX pin/0000"></uattr>
            </io_usage>
        </resource_ref>
        <sccode name="event0" init_power_mode="0"><![CDATA[//Auto mode
//cancel all scheduled event triggers
//evhCancelTrigger(0);
evhCancelTrigger(1);
//evhCancelTrigger(2);
// update state's TDD mode, channels select and unit Type from the cfg (only on the start of a new sampling cycle)
if(state.samplesCount == SAMPLE_SIZE){
    state.tddMode = cfg.tddMode;
    state.channelsSwitch = cfg.channelsSwitch;
    state.unitType = cfg.unitType;
}

// check if the TDD mode was changed in the middle of the sampling cycles
if(state.tddMode == cfg.tddMode){
    state.invalid = 0;
} else{
    // if it was, mark currently stored result as invalid, advance the sample counter to the last cycle
    // and trigger the next event so results will get discarded
    state.invalid = 1;
    state.samplesCount = 1;
    evhSetupTimer0Trigger(1, 1, 2);
    fwWaitForEvSignal(FW_WAIT_SIGNAL_TIMER0_EV, 1);
}

// if tdd mode is auto
if(state.tddMode == 0){
    //    if(state.ledCounter == 0){
    //        gpioClearOutput(AUXIO_O_RED_LED);
    //        gpioClearOutput(AUXIO_O_GREEN_LED);
    //    }
    //   if(state.ledCounter >= 100){
    //      gpioClearOutput(AUXIO_O_RED_LED);
    //     gpioClearOutput(AUXIO_O_GREEN_LED);
    //    state.ledCounter = 0;
    //}
    //    state.ledCounter += 1;

    //get the TDD lock
    U16 lock;
    if(state.unitType == 0){
        // in CDU we get it directly from the PIN
        gpioGetInputValue(AUXIO_I_TDD_LOCK; lock);
        // lock detect PIN: 0-locked, 1-not locked (XOR to flip it)
        lock ^= 1;


    }else{
        // CRU gets lock status via a meassage from CDU, checks and updates periodically
        lock = input.tddLock;
    }

    if(lock == 1){ //Auto mode : locked - Steady Pink
        gpioSetOutput(AUXIO_O_RED_LED);
        gpioSetOutput(AUXIO_O_GREEN_LED);

        if(state.ledOn==0){
            gpioClearOutput(AUXIO_O_RED_LED);
            gpioClearOutput(AUXIO_O_GREEN_LED);
        }
    }else{ //Auto mode : unlocked - Flashing Pink
        if(state.ledCounter <= 25){
            gpioSetOutput(AUXIO_O_RED_LED);
            gpioSetOutput(AUXIO_O_GREEN_LED);
        }
        if(state.ledCounter >= 25){
            gpioClearOutput(AUXIO_O_RED_LED);
            gpioClearOutput(AUXIO_O_GREEN_LED);

        }
        state.ledCounter += 1;
        if(state.ledCounter == 50){
            state.ledCounter = 0;
        }

    }
    if(state.ledOn==0){
        gpioClearOutput(AUXIO_O_RED_LED);
        gpioClearOutput(AUXIO_O_GREEN_LED);
    }



    //if locked, activate the rising edge interrupt on event B
    if(lock == 1){
        evhSetupGpioTrigger(1, AUXIO_I_TDD_SYNCH, 1, EVH_GPIO_TRIG_ON_EDGE);
    }
    //Activate timer trigger on event A, so if interrupt does not occur or there is no lock then
    //event runs again from the start
    //timer of 100 ms
    evhSetupTimer0Trigger(0, 100, 2);

}else{
    // if mode is not auto, trigger event B immediately
    evhSetupTimer0Trigger(1, 1, 2);
}
//evhSetupGpioTrigger(1, AUXIO_I_TDD_SYNCH, 1, EVH_GPIO_TRIG_ON_MATCH);]]></sccode>
        <sccode name="event1" init_power_mode="0"><![CDATA[//DownLink
//cancel all scheduled event triggers

evhCancelTrigger(0);
//evhCancelTrigger(1);
//evhCancelTrigger(2);
//enter event code only if Manual DL mode or Auto(skip if Manual UL)
if(state.tddMode != 2){

    // turn DL LED on (in auto mode it stays on only half the time)
    if(state.tddMode == 1){ //Manual DL - Steady Blue
        U16 valueTddSyncPin;
        gpioGetInputValue(AUXIO_I_TDD_SYNCH; valueTddSyncPin);
        if(valueTddSyncPin == 1){
            cfg.eventCounter += 1;
        }
        // if(state.ledCounter < 50){
        gpioClearOutput(AUXIO_O_RED_LED);
        gpioSetOutput(AUXIO_O_GREEN_LED);
        //  }
    }//else{
    //    gpioClearOutput(AUXIO_O_RED_LED);
    //    gpioSetOutput(AUXIO_O_GREEN_LED);
    //  }
    if(state.ledOn==0){
        gpioClearOutput(AUXIO_O_RED_LED);
        gpioClearOutput(AUXIO_O_GREEN_LED);
    }
    U16 n = 0;
    n = state.samplesCount;
    // randomDelay to wait on in microseconds that is delivered by application.
    fwDelayUs(input.randomDelayDL[n]);

    // start the ADC driver
    adcEnableSync(ADC_REF_FIXED, ADC_SAMPLE_TIME_2P7_US, ADC_TRIGGER_MANUAL); // manual sampling, 2.7 us sample time

    // Initialize variables, only 6 are available
    U16 a = 0;
    S16 b = 0;
    U16 c = 0;
    U16 d = 0;

    n = 0;
    while (n < MULTI_BUFFER_SIZE) {
        // select the correct channel according to cfg variable.
        // select the first channel in case channelsSwitch is set to all channels
        while(a < CHANNELS_NUMBER){
            // Select channel
            // a = channel
            // when channelsSwitch is 0 we switch between all channels using the iterator a
            if(state.channelsSwitch==0){
                b = a + 1;
            } else{
                // if it is not 0, we measure only the selected channel
                b = state.channelsSwitch;
            }
            // first we set both pin to select the first channel (in cdu both pins 1, in cru both pins 0)
            if(state.unitType == 0){
                gpioSetOutput(cfg.pAuxioOChannelControl[0]);
                gpioSetOutput(cfg.pAuxioOChannelControl[1]);
            }
            if(state.unitType == 1){
                gpioClearOutput(cfg.pAuxioOChannelControl[0]);
                gpioClearOutput(cfg.pAuxioOChannelControl[1]);
            }
            // then we toggle the correct pins according to the chosen channel
            c = b ^ 1;
            c = c & 1;
            if(c==1){
                gpioToggleOutput(cfg.pAuxioOChannelControl[0]);
            }

            if(b >= 3){
                gpioToggleOutput(cfg.pAuxioOChannelControl[1]);
            }

            // select the correct pin according to unit type. For CDU we select
            // Rx detect PIN(Tal's card), for CRU we select Tx detect PIN(FEM card)
            if(state.unitType == 0){
                adcSelectGpioInput(cfg.pAuxioASensorOutput[0]);
            }else{
                adcSelectGpioInput(cfg.pAuxioASensorOutput[1]);
            }
            // this triggers the driver to start a measure and place the result in the output array
            adcGenManualTrigger();
            adcReadFifo(output.pSamplesMultiChannelRF[n]);
            // select the IF pin
            adcSelectGpioInput(cfg.pAuxioASensorOutput[2]);
            // IF requires same PIN setup as RX Detect, so for CRU (who have TX detect selected)
            // we toggle the channel select pins (as for TX Detect they are exact opposites)
            if(state.unitType == 1){
                gpioToggleOutput(cfg.pAuxioOChannelControl[0]);
                gpioToggleOutput(cfg.pAuxioOChannelControl[1]);
            }
            adcGenManualTrigger();
            adcReadFifo(output.pSamplesMultiChannelIF[n]);
            // toggle channel select PINs back
            if(state.unitType == 1){
                gpioToggleOutput(cfg.pAuxioOChannelControl[0]);
                gpioToggleOutput(cfg.pAuxioOChannelControl[1]);
            }

            // copy n value to temp variable, we do this because n is the only variable that can access arrays,
            // but we also use it as the loop counter so we need to save it's value.
            b = n;

            // add IF and RF results to the average arrays for later average calulation
            // the average array is arranged as: 0-3: RFDL, 4-7: RFUL, 8-11: IFDL, 12-15: IFUL (4 of each type for each channel)
            // for accessing RFDL sums we don't add anything to n so we get positions 0-3, for IFDL we add 8 to n to get to positions 8-11
            c = output.pSamplesMultiChannelRF[n];
            d = output.pSamplesMultiChannelIF[n];
            n = a;
            output.channelsAverageTemp[n] += c;
            n = a + 8;
            output.channelsAverageTemp[n] += d;
            n = b;

            n += 1;
            a += 1;
            // Select channel again
        }
        a = 0;
    }
    // Disable the ADC driver after use
    adcDisable();
    // reset all variables and decalre the rest of necessary variables
    U16 e = 0;
    U16 f = 0;
    a = 0;
    b = 0;
    c = 0;
    n = 0;

    // in this loop we get top and bottom 20% of results from samples
    while(f < CHANNELS_NUMBER){
        while(n<BUFFER_SIZE){
            // samples array is arranged as [channelSample1, channelSample2, channelSample3, channelSample4, channelSample1...] (channels alternating)
            // the max/min arrays are arranged by channels and sorted smallest to biggest/ biggest to smallest:
            // [channelSample1, channelSampleBigger1, channelSampleBiggest1, channelSample2, channelSampleBigger2...](for min arrays -> bigger to smallest)
            // we iterate on each channel, taking and comparing the channels samples currently in the buffer to the ones in the max/min arrays.
            // If any of the samples is bigger/smaller than the ones stored in the max/min array, we move all samples in the array down/up and insert the new sample.
            c = n;
            // make jumps of CHANNELS_NUMBER on samples array - multiply n by iterator and add the current channel number
            accMul16s16u(n, CHANNELS_NUMBER);
            accGet16(0; n);
            n += f;
            a = output.pSamplesMultiChannelRF[n];
            // check if this sample is greater/lesser than the ones already stored in the max/min
            // because these array start with values of 0(for max)/0xffff(for min), first results will always get into the array
            b = MODES_CHANNEL_SIZE - 1;
            while( b >= 0){
                // multiply current channel(f) by the number of results stored for each channel to get the channel's position in the max/min array
                accMul16s16u(f, MODES_CHANNEL_SIZE);
                accGet16(0; n);
                n += b;
                d = output.maxSamplesRFDL[n];
                // check if smaple is greater than any of the samples in maxSamples
                if(d < a){
                    // insert current sample to new position
                    output.maxSamplesRFDL[n] = a;
                    // here we 'move' all smaller samples down the array (deleting the first smallest sample)
                    // this makes it so array will be sorted samller -> biggest
                    while(0 < b){
                        n -= 1;
                        b -= 1;
                        e = output.maxSamplesRFDL[n];
                        output.maxSamplesRFDL[n] = d;
                        d = e;
                    }
                    // set b to 0 so loop will break
                    b = 0;
                }
                b -=1;
            }

            // repeat this for minimum array
            b = 0;
            b = 0;
            while( b < MODES_CHANNEL_SIZE){
                // multiply current channel(f) by the number of results stored for each channel to get the channel's position in the max/min array
                accMul16s16u(f, MODES_CHANNEL_SIZE);
                accGet16(0; n);
                n += b;
                d = output.minSamplesRFDL[n];
                // check if smaple is lesser than any of the samples in minSamples
                if(d > a){
                    // insert current sample to new position
                    output.minSamplesRFDL[n] = a;
                    // here we 'move' all bigger samples up the array (deleting the last biggest sample)
                    // this makes it so array will be sorted bigger -> smallest
                    while(b < (MODES_CHANNEL_SIZE-1)){
                        n += 1;
                        b += 1;
                        e = output.minSamplesRFDL[n];
                        output.minSamplesRFDL[n] = d;
                        d = e;
                    }
                    b = MODES_CHANNEL_SIZE; // so loop will break
                }
                b +=1;
            }
            // repeat whole process for the IF samples
            n = c;
            accMul16s16u(n, CHANNELS_NUMBER);
            accGet16(0; n);
            n += f;
            a = output.pSamplesMultiChannelIF[n];
            b = MODES_CHANNEL_SIZE - 1;

            while(b >= 0){
                accMul16s16u(f, MODES_CHANNEL_SIZE);
                accGet16(0; n);
                n += b;
                d = output.maxSamplesIFDL[n];
                if(d < a){
                    output.maxSamplesIFDL[n] = a;
                    while(0 < b){
                        n -= 1;
                        b -= 1;
                        e = output.maxSamplesIFDL[n];
                        output.maxSamplesIFDL[n] = d;
                        d = e;
                    }
                    b = 0; // so loop will break
                }
                b -=1;
            }

            b = 0;
            while( b < MODES_CHANNEL_SIZE){
                accMul16s16u(f, MODES_CHANNEL_SIZE);
                accGet16(0; n);
                n += b;
                d = output.minSamplesIFDL[n];
                if(d > a){
                    output.minSamplesIFDL[n] = a;
                    while(b < (MODES_CHANNEL_SIZE-1)){
                        n += 1;
                        b += 1;
                        e = output.minSamplesIFDL[n];
                        output.minSamplesIFDL[n] = d;
                        d = e;
                    }
                    b = MODES_CHANNEL_SIZE; // so loop will break
                }
                b +=1;
            }

            n = c;
            n += 1;
        }
        n = 0;
        f += 1;

    }

    // decrease the sample cycle counter
    state.samplesCount -= 1;

    // reset variables
    n = 0;
    a = 0;
    b = 0;
    c = 0;
    d = 0;
    e = 0;
    f = 0;

    // if this is the last cylce of measures, process the result
    if(state.samplesCount == 0){
        // clear values in temp Samples arrays (there we put the sums of results)
        while(n<CHANNELS_NUMBER){
            output.channelsMaxRFDLTemp[n] = 0;
            output.channelsMaxIFDLTemp[n] = 0;
            output.channelsMinRFDLTemp[n] = 0;
            output.channelsMinIFDLTemp[n] = 0;
            n +=1;
        }
        // we now have in the output.maxSamples array the top 20% of results from each channel (for RF and IF).
        // in output.minSamples we got bottom 20% of results from each channel (for RF and IF).
        // we want to discard top 5% bottom and top from all sums - min max and average (get rid of the outliers).
        // the remaining 15% top/bottom of results we sum and copy into output.channelsMax/output.channelsMin arrays
        // we also subtruct those 5% top/bottom results from the sums in the average arrays.

        n = 0;
        while(f<CHANNELS_NUMBER){
            // we iterate on each channel results
            while(a<MODES_CHANNEL_SIZE){
                // for each channel, we sum it's first/last 15% samples (out of total 20% we got in the array),
                // the remaining 5% we subtract from the average sum array (as they were added to the total sum)
                b = n;
                c = output.maxSamplesRFDL[n];
                d = output.maxSamplesIFDL[n];
                n = f;
                if(a<MIN_MAX_CHANNELS_SIZE){
                    // if results are within the 15%, add them to the sums array
                    output.channelsMaxRFDLTemp[n] += c;
                    output.channelsMaxIFDLTemp[n] += d;
                }else{
                    // otherwise subtruct the 5% from the average sum
                    // RFDL positions 0-3
                    output.channelsAverageTemp[n] -= c;
                    // to get to IFDL we add 8: positions 8-11
                    n += 8;
                    output.channelsAverageTemp[n] -= d;
                }
                n = b;
                // repeat for min
                c = output.minSamplesRFDL[n];
                d = output.minSamplesIFDL[n];
                n = f;
                if(a<MIN_MAX_CHANNELS_SIZE){
                    // if results are within the 15%, add them to the sums array
                    output.channelsMinRFDLTemp[n] += c;
                    output.channelsMinIFDLTemp[n] += d;
                }else{
                    // RFDL positions 0-3
                    output.channelsAverageTemp[n] -= c;
                    // to get to IFDL we add 8: positions 8-11
                    n += 8;
                    output.channelsAverageTemp[n] -= d;
                }
                n = b;
                a+=1;
                n+=1;
            }
            a = 0;
            f += 1;
        }

        // clear values in maxSamples/minSamples arrays
        n = 0;
        while(n<MODES_SIZE){
            output.maxSamplesRFDL[n] = 0;
            output.maxSamplesIFDL[n] = 0;
            output.minSamplesRFDL[n] = 65535;
            output.minSamplesIFDL[n] = 65535;
            n += 1;
        }

        if(state.invalid != 1){
            // copy the results from the temp array to the 'real' array
            n = 0;
            while(n<CHANNELS_NUMBER){
                output.channelsMaxRFDL[n] = output.channelsMaxRFDLTemp[n];
                output.channelsMaxIFDL[n] = output.channelsMaxIFDLTemp[n];
                output.channelsMinRFDL[n] = output.channelsMinRFDLTemp[n];
                output.channelsMinIFDL[n] = output.channelsMinIFDLTemp[n];
                n += 1;
            }
        }
        // copy average sums vaules from the temp array to the 'real' array and clear temp array
        n = 0;
        a = 0;
        while(n<CHANNELS_NUMBER){
            a = n;
            if(state.invalid != 1){
                output.channelsAverage[n] = output.channelsAverageTemp[n];
            }
            output.channelsAverageTemp[n] = 0;
            n += 8;
            if(state.invalid != 1){
                output.channelsAverage[n] = output.channelsAverageTemp[n];
            }
            output.channelsAverageTemp[n] = 0;
            n = a;
            n += 1;
        }
        if(state.invalid != 1){
            // if TDD mode is manual DL, results are ready and an interrupt is sent to main CPU
            n = 0;
            if(state.tddMode == 1){
                state.samplesCount = SAMPLE_SIZE;
                rtlLogStructs(BV_RTL_LOG_OUTPUT);
                // if interrupt flag is enabled, raises the interrupt for application to process results
                if(state.alertEnabled == 1) {
                    state.alertEnabled = 0;
                    fwGenQuickAlertInterrupt();
                }
            }
        } else{
            state.samplesCount = SAMPLE_SIZE;
            evhSetupTimer0Trigger(2, 1, 2);
            fwWaitForEvSignal(FW_WAIT_SIGNAL_TIMER0_EV, 1);
        }
    }
    // if TDD mode is auto, trigger the next falling edge interrupt for UL Event C
    if(state.tddMode == 0){
        evhSetupGpioTrigger(2, AUXIO_I_TDD_SYNCH, 0, EVH_GPIO_TRIG_ON_EDGE);
        evhSetupTimer0Trigger(0, 100, 2);
    }else{
        // if not, immediately trigger event A
        evhSetupTimer0Trigger(2, 1, 2);
    }
}else{
    // if mode is not Manual DL/ Auto, immediately trigger event C
    evhSetupTimer0Trigger(2, 1, 2);
}]]></sccode>
        <sccode name="event2" init_power_mode="0"><![CDATA[//UpLink
//cancel all scheduled event triggers

evhCancelTrigger(0);
//evhCancelTrigger(1);
//evhCancelTrigger(2);
//enter event code only if Manual UL mode or Auto(skip if Manual DL)
if(state.tddMode != 1){

    // turn UL LED on (in auto mode it stays on only half the time)
    if(state.tddMode == 2 ){ //Manual UL - Steady Orange
         U16 valueTddSyncPin;
        gpioGetInputValue(AUXIO_I_TDD_SYNCH; valueTddSyncPin);
        if(valueTddSyncPin == 0){
            cfg.eventCounter -= 1;
        }
        // if(state.ledCounter > 50){
        gpioClearOutput(AUXIO_O_GREEN_LED);
        gpioSetOutput(AUXIO_O_RED_LED);
        //  }
    }
    //else{
    //     gpioClearOutput(AUXIO_O_GREEN_LED);
    //     gpioSetOutput(AUXIO_O_RED_LED);
    //  }
    if(state.ledOn==0){
        gpioClearOutput(AUXIO_O_RED_LED);
        gpioClearOutput(AUXIO_O_GREEN_LED);
    }
    U16 n = 0;
    n = state.samplesCount;
    // randomDelay to wait on in microseconds that is delivered by application.
    fwDelayUs(input.randomDelayUL[n]);

    // start the ADC driver
    adcEnableSync(ADC_REF_FIXED, ADC_SAMPLE_TIME_2P7_US, ADC_TRIGGER_MANUAL); // manual sampling, 2.7 us sample time

    // Initialize variables, only 6 are available
    U16 a = 0;
    S16 b = 0;
    U16 c = 0;
    U16 d = 0;

    n = 0;
    while (n < MULTI_BUFFER_SIZE) {
        // select the correct channel according to cfg variable.
        // select the first channel in case channelsSwitch is set to all channels
        while(a < CHANNELS_NUMBER){
            // Select channel
            // a = channel
            // when channelsSwitch is 0 we switch between all channels using the iterator a
            if(state.channelsSwitch==0){
                b = a + 1;
            } else{
                // if it is not 0, we measure only the selected channel
                b = state.channelsSwitch;
            }
            // first we set both pin to select the first channel (in cdu both pins 1, in cru both pins 0)
            if(state.unitType == 1){
                gpioSetOutput(cfg.pAuxioOChannelControl[0]);
                gpioSetOutput(cfg.pAuxioOChannelControl[1]);
            }
            if(state.unitType == 0){
                gpioClearOutput(cfg.pAuxioOChannelControl[0]);
                gpioClearOutput(cfg.pAuxioOChannelControl[1]);
            }
            // then we toggle the correct pins according to the chosen channel
            c = b ^ 1;
            c = c & 1;
            if(c==1){
                gpioToggleOutput(cfg.pAuxioOChannelControl[0]);
            }

            if(b >= 3){
                gpioToggleOutput(cfg.pAuxioOChannelControl[1]);
            }

            // select the correct pin according to unit type. For CRU we select
            // Rx detect PIN(Tal's card), for CDU we select Tx detect PIN(FEM card)
            if(state.unitType == 0){
                adcSelectGpioInput(cfg.pAuxioASensorOutput[1]);
            }else{
                adcSelectGpioInput(cfg.pAuxioASensorOutput[0]);
            }
            // this triggers the driver to start a measure and place the result in the output array
            adcGenManualTrigger();
            adcReadFifo(output.pSamplesMultiChannelRF[n]);
            // select the IF pin
            adcSelectGpioInput(cfg.pAuxioASensorOutput[2]);
            // IF requires same PIN setup as RX Detect, so for CDU (who have TX detect selected)
            // we toggle the channel select pins (as for TX Detect they are exact opposites)
            if(state.unitType == 0){
                gpioToggleOutput(cfg.pAuxioOChannelControl[0]);
                gpioToggleOutput(cfg.pAuxioOChannelControl[1]);
            }
            adcGenManualTrigger();
            adcReadFifo(output.pSamplesMultiChannelIF[n]);
            // toggle channel select PINs back
            if(state.unitType == 0){
                gpioToggleOutput(cfg.pAuxioOChannelControl[0]);
                gpioToggleOutput(cfg.pAuxioOChannelControl[1]);
            }

            // copy n value to temp variable, we do this because n is the only variable that can access arrays,
            // but we also use it as the loop counter so we need to save it's value.
            b = n;

            // add IF and RF results to the average arrays for later average calulation
            // the average array is arranged as: 0-3: RFDL, 4-7: RFUL, 8-11: IFDL, 12-15: IFUL (4 of each type for each channel)
            // here we add 4 to n before adding the RF to sums to get to positions 4-7 and 12 to n before adding the IF sums to get 13-15
            c = output.pSamplesMultiChannelRF[n];
            d = output.pSamplesMultiChannelIF[n];
            n = a + 4;
            output.channelsAverageTemp[n] += c;
            n = a + 12;
            output.channelsAverageTemp[n] += d;
            n = b;

            n += 1;
            a += 1;
        }
        a = 0;
    }
    // Disable the ADC driver after use
    adcDisable();
    // reset all variables and decalre the rest of necessary variables
    U16 e = 0;
    U16 f = 0;
    a = 0;
    b = 0;
    c = 0;
    n = 0;

    // in this loop we get top and bottom 20% of results from samples
    while(f < CHANNELS_NUMBER){
        while(n<BUFFER_SIZE){
            // samples array is arranged as [channelSample1, channelSample2, channelSample3, channelSample4, channelSample1...] (channels alternating)
            // the max/min arrays are arranged by channels and sorted smallest to biggest/ biggest to smallest:
            // [channelSample1, channelSampleBigger1, channelSampleBiggest1, channelSample2, channelSampleBigger2...]
            // we iterate on each channel, taking and comparing the channels samples currently in the buffer to the ones in the max/min arrays.
            // If any of the samples is bigger/smaller than the ones stored in the max/min array, we move all samples in the array down/up and insert the new sample.
            c = n;
            // make jumps of CHANNELS_NUMBER on samples array - multiply n by iterator and add the current channel number
            accMul16s16u(n, CHANNELS_NUMBER);
            accGet16(0; n);
            n += f;
            a = output.pSamplesMultiChannelRF[n];
            // check if this sample is greater/lesser than the ones already stored in the max/min
            // because these array start with values of 0(for max)/0xffff(for min), first results will always get into the array
            b = MODES_CHANNEL_SIZE - 1;
            while( b >= 0){
                // multiply current channel(f) by the number of results stored for each channel to get the channel's position in the max/min array
                accMul16s16u(f, MODES_CHANNEL_SIZE);
                accGet16(0; n);
                n += b;
                d = output.maxSamplesRFUL[n];
                // check if smaple is greater than any of the samples in maxSamples
                if(d < a){
                    // insert current sample to new position
                    output.maxSamplesRFUL[n] = a;
                    // here we 'move' all smaller samples down the array (deleting the first smallest sample)
                    // this makes it so array will be sorted samller -> biggest
                    while(0 < b){
                        n -= 1;
                        b -= 1;
                        e = output.maxSamplesRFUL[n];
                        output.maxSamplesRFUL[n] = d;
                        d = e;
                    }
                    // set b to 0 so loop will break
                    b = 0;
                }
                b -=1;
            }

            // repeat this for minimum array
            b = 0;
            // check if smaple is lesser than any of the samples in minmodes
            while( b < MODES_CHANNEL_SIZE){
                // multiply current channel(f) by the number of results stored for each channel to get the channel's position in the max/min array
                accMul16s16u(f, MODES_CHANNEL_SIZE);
                accGet16(0; n);
                n += b;
                d = output.minSamplesRFUL[n];
                // check if smaple is lesser than any of the samples in minSamples
                if(d > a){
                    // insert current sample to new position
                    output.minSamplesRFUL[n] = a;
                    // here we 'move' all bigger samples up the array (deleting the last biggest sample)
                    // this makes it so array will be sorted bigger -> smallest
                    while(b < (MODES_CHANNEL_SIZE-1)){
                        n += 1;
                        b += 1;
                        e = output.minSamplesRFUL[n];
                        output.minSamplesRFUL[n] = d;
                        d = e;
                    }
                    b = MODES_CHANNEL_SIZE; // so loop will break
                }
                b +=1;
            }

            // repeat whole process for the IF samples
            n = c;
            accMul16s16u(n, CHANNELS_NUMBER);
            accGet16(0; n);
            n += f;
            a = output.pSamplesMultiChannelIF[n];
            b = MODES_CHANNEL_SIZE - 1;
            while(b >= 0){
                accMul16s16u(f, MODES_CHANNEL_SIZE);
                accGet16(0; n);
                n += b;
                d = output.maxSamplesIFUL[n];
                if(d < a){
                    output.maxSamplesIFUL[n] = a;
                    while(0 < b){
                        n -= 1;
                        b -= 1;
                        e = output.maxSamplesIFUL[n];
                        output.maxSamplesIFUL[n] = d;
                        d = e;
                    }
                    b = 0; // so loop will break
                }
                b -=1;
            }

            b = 0;
            // check if smaple is lesser than any of the samples in minmodes
            while( b < MODES_CHANNEL_SIZE){
                accMul16s16u(f, MODES_CHANNEL_SIZE);
                accGet16(0; n);
                n += b;
                d = output.minSamplesIFUL[n];
                if(d > a){
                    output.minSamplesIFUL[n] = a;
                    while(b < (MODES_CHANNEL_SIZE-1)){
                        n += 1;
                        b += 1;
                        e = output.minSamplesIFUL[n];
                        output.minSamplesIFUL[n] = d;
                        d = e;
                    }
                    b = MODES_CHANNEL_SIZE; // so loop will break
                }
                b +=1;
            }

            n = c;
            n += 1;
        }
        n = 0;
        f += 1;

    }

    // decrease the sample cycle counter only if mode is manualUL(if we are in auto the counter was already changed by UL event).
    if(state.tddMode == 2){
        state.samplesCount -= 1;
    }

    n = 0;
    a = 0;
    b = 0;
    c = 0;
    d = 0;
    e = 0;
    f = 0;
    // if this is the last cylce of measures, process the result
    if(state.samplesCount == 0){
        // clear values in temp Samples arrays (there we put the sums of results)
        while(n<CHANNELS_NUMBER){
            output.channelsMaxRFULTemp[n] = 0;
            output.channelsMaxIFULTemp[n] = 0;
            output.channelsMinRFULTemp[n] = 0;
            output.channelsMinIFULTemp[n] = 0;
            n +=1;
        }
        // we now have in the output.maxSamples array the top 20% of results from each channel (for RF and IF).
        // in output.minSamples we got bottom 20% of results from each channel (for RF and IF).
        // we want to discard top 5% bottom and top from all sums - min max and average (get rid of the outliers).
        // the remaining 15% top/bottom of results we sum and copy into output.channelsMax/output.channelsMin arrays
        // we also subtruct those 5% top/bottom results from the sums in the average arrays.

        n = 0;
        while(f<CHANNELS_NUMBER){
            // we iterate on each channel results
            while(a<MODES_CHANNEL_SIZE){
                // for each channel, we sum it's first/last 15% samples (out of total 20% we got in the array),
                // the remaining 5% we subtract from the average sum array (as they were added to the total sum)
                b = n;
                c = output.maxSamplesRFUL[n];
                d = output.maxSamplesIFUL[n];
                n = f;
                if(a<MIN_MAX_CHANNELS_SIZE){
                    // if results are within the 15%, add them to the sums array
                    output.channelsMaxRFULTemp[n] += c;
                    output.channelsMaxIFULTemp[n] += d;
                }else{
                    // otherwise subtruct the 5% from the average sum
                    n += 4;
                    output.channelsAverageTemp[n] -= c;
                    n += 8;
                    output.channelsAverageTemp[n] -= d;
                }

                n = b;
                // repeat for min
                c = output.minSamplesRFUL[n];
                d = output.minSamplesIFUL[n];
                n = f;
                if(a<MIN_MAX_CHANNELS_SIZE){
                    // if results are within the 15%, add them to the sums array
                    output.channelsMinRFULTemp[n] += c;
                    output.channelsMinIFULTemp[n] += d;
                }else{
                    // to get to RFUL we add 4: positions 4-7
                    n += 4;
                    output.channelsAverageTemp[n] -= c;
                    // to get to IFUL we add 8: positions 12-15
                    n += 8;
                    output.channelsAverageTemp[n] -= d;
                }

                n = b;
                a+=1;
                n+=1;
            }
            a = 0;
            f += 1;
        }

        // clear values in maxSamples/minSamples arrays
        n = 0;
        while(n<MODES_SIZE){
            output.maxSamplesRFUL[n] = 0;
            output.maxSamplesIFUL[n] = 0;
            output.minSamplesRFUL[n] = 65535;
            output.minSamplesIFUL[n] = 65535;
            n += 1;
        }
        if(state.invalid != 1){
            // copy the results from the temp array to the 'real' array
            n = 0;
            while(n<CHANNELS_NUMBER){
                output.channelsMaxRFUL[n] = output.channelsMaxRFULTemp[n];
                output.channelsMaxIFUL[n] = output.channelsMaxIFULTemp[n];
                output.channelsMinRFUL[n] = output.channelsMinRFULTemp[n];
                output.channelsMinIFUL[n] = output.channelsMinIFULTemp[n];
                n += 1;
            }
        }

        // copy average sums vaules from the temp array to the 'real' array and clear temp array
        n = 0;
        a = 0;
        while(n<CHANNELS_NUMBER){
            a = n;
            n += 4;
            if(state.invalid != 1){
                output.channelsAverage[n] = output.channelsAverageTemp[n];
            }
            output.channelsAverageTemp[n] = 0;
            n += 8;
            if(state.invalid != 1){
                output.channelsAverage[n] = output.channelsAverageTemp[n];
            }
            output.channelsAverageTemp[n] = 0;
            n = a;
            n += 1;
        }
        if(state.invalid != 1){
            // if TDD mode is manual UL or Auto, results are ready and an interrupt is sent to main CPU
            n = 0;
            state.samplesCount = SAMPLE_SIZE;
            rtlLogStructs(BV_RTL_LOG_OUTPUT);
            // if interrupt flag is enabled, raises the interrupt for application to process results
            if(state.alertEnabled == 1) {
                state.alertEnabled = 0;
                fwGenQuickAlertInterrupt();
            }
        } else{
            state.samplesCount = SAMPLE_SIZE;
            evhSetupTimer0Trigger(0, 1, 2);
            fwWaitForEvSignal(FW_WAIT_SIGNAL_TIMER0_EV, 1);
        }
    }

}
// trigger event A
evhSetupTimer0Trigger(0, 1, 2);]]></sccode>
        <sccode name="event3" init_power_mode="0"><![CDATA[]]></sccode>
        <sccode name="execute" init_power_mode="0"><![CDATA[]]></sccode>
        <sccode name="initialize" init_power_mode="0"><![CDATA[//immediately start event A code
gpioClearOutput(AUXIO_O_RED_LED);
gpioClearOutput(AUXIO_O_GREEN_LED);
evhSetupTimer0Trigger(0, 1, 0);]]></sccode>
        <sccode name="terminate" init_power_mode="0"><![CDATA[// cancel events trigger on termination
gpioClearOutput(AUXIO_O_RED_LED);
gpioClearOutput(AUXIO_O_GREEN_LED);
evhCancelTrigger(0);
evhCancelTrigger(1);
evhCancelTrigger(2);]]></sccode>
        <event_trigger active_count="3">0,1,2,3</event_trigger>
        <tt_iter>run_event0,run_event1,run_event2</tt_iter>
        <tt_struct>output.pSamplesMultiChannelIF.[0],output.pSamplesMultiChannelIF.[1],output.pSamplesMultiChannelIF.[2],output.pSamplesMultiChannelIF.[3],output.pSamplesMultiChannelIF.[4],output.pSamplesMultiChannelIF.[5],output.pSamplesMultiChannelIF.[6],output.pSamplesMultiChannelIF.[7],output.pSamplesMultiChannelIF.[8],output.pSamplesMultiChannelIF.[9],output.pSamplesMultiChannelIF.[10],output.pSamplesMultiChannelIF.[11],output.pSamplesMultiChannelIF.[12],output.pSamplesMultiChannelIF.[13],output.pSamplesMultiChannelIF.[14],output.pSamplesMultiChannelIF.[15],output.pSamplesMultiChannelIF.[16],output.pSamplesMultiChannelIF.[17],output.pSamplesMultiChannelIF.[18],output.pSamplesMultiChannelIF.[19],output.pSamplesMultiChannelIF.[20],output.pSamplesMultiChannelIF.[21],output.pSamplesMultiChannelIF.[22],output.pSamplesMultiChannelIF.[23],output.pSamplesMultiChannelIF.[24],output.pSamplesMultiChannelIF.[25],output.pSamplesMultiChannelIF.[26],output.pSamplesMultiChannelIF.[27],output.pSamplesMultiChannelIF.[28],output.pSamplesMultiChannelIF.[29],output.pSamplesMultiChannelIF.[30],output.pSamplesMultiChannelIF.[31],output.pSamplesMultiChannelIF.[32],output.pSamplesMultiChannelIF.[33],output.pSamplesMultiChannelIF.[34],output.pSamplesMultiChannelIF.[35],output.pSamplesMultiChannelIF.[36],output.pSamplesMultiChannelIF.[37],output.pSamplesMultiChannelIF.[38],output.pSamplesMultiChannelIF.[39]</tt_struct>
        <rtl_struct>cfg.tddMode</rtl_struct>
        <rtl_task_sel en="1" struct_log_list="output,cfg"/>
    </task>
</project>
